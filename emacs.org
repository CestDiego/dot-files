#+TITLE:  Emacs Configuration File
#+AUTHOR: Howard Abrams
#+EMAIL:  howard.abrams@gmail.com

* Introduction

  This is my =.emacs= file, written using [[http://www.orgmode.org][org-mode]], so that I can
  organize it and take notes on all the complexity.

#+BEGIN_HTML
  <p>
    You can download the <a href="dot-emacs.org">original org-mode
    file</a> or view the <a href="dot-emacs.el">tangled end results</a>.
  </p>
#+END_HTML

  If you are playing around with the =org-mode= version, note:

  - The =tab= key opens/close a particular section
  - Shift + =tab= cycles between the outline and full text
  - Render it with:  =C-c C-v t=
  - Creates a file:  =~/.emacs-ext.el=

** Emacs Executable

   This file is really a /script/ that requires version 24 of Emacs.
   While I often use [[http://emacsformacosx.com/builds][Emacs for Mac]], lately, I've been building from
   [[http://brew.sh/][Homebrew]] with the following:

#+BEGIN_SRC sh :tangle no
brew install emacs --HEAD --cocoa --srgb
brew linkapps
#+END_SRC

   Not only does this install the latest version of Emacs in
   =/usr/local/bin/emacs=, but it also links a GUI version in
   =/Application/Emacs.app=. Goody.

** Loading this File

   To "load" the contents of this file, add the following to =$HOME/.emacs=:

#+BEGIN_EXAMPLE
  ;; Load our Literate Programming version of our Dot Emacs
  ;; file, from file: ~/Work/dot-files/emacs.org
  (unless (boundp 'aquamacs-version)
    (load-file "~/.emacs-ext.el"))
#+END_EXAMPLE

   *Note:* I only load this from a "normal" Emacs distribution, which allows
   me to play around with [[http://aquamacs.org/][Aquamacs]] and [[http://eschulte.github.io/emacs-starter-kit/][Starter Kits]] for recommendation
   to people new to Emacs.

** Editing Warning

  Begin this initialization script with a warning not to edit the
  generated file:

#+NAME: Note
#+BEGIN_SRC elisp :comments off
  ;;; ------------------------------------------
  ;;; Do not edit the generated file, as it has
  ;;; been generated, as a tangled file, by the
  ;;; fandifluous org-mode.
  ;;;
  ;;; Source: ~/Work/dot-files/emacs.org
  ;;; ------------------------------------------
#+END_SRC

* General Settings

** Extra Packages

   Extra packages not available via the package manager go in my
   personal stash at: =$HOME/.emacs.d/elisp=

#+BEGIN_SRC elisp
  (add-to-list 'load-path (concat (getenv "HOME") "/.emacs.d/elisp"))
#+END_SRC

   Make sure that =PATH= variable for finding binary files can
   is the same as what Emacs will look for binary files...but only if
   we are running from the =Applications= directory.

#+BEGIN_SRC elisp
  (when window-system 
    (let ((path-from-shell (shell-command-to-string "bash -i -c 'echo $PATH'")))
      (setenv "PATH" path-from-shell)
      (setq exec-path (split-string path-from-shell path-separator))))
#+END_SRC

** Package Manager

   Emacs has become like every other operating system, and now has a
   [[http://tromey.com/elpa/][package manager]] with its own collection repository, but since it is
   so conservative, we need to add more repositories to get all the
   sweet goodness, I demand.

#+BEGIN_SRC elisp
  ; (load "~/.emacs.d/elpa/package.el") Needed for version 23 only!
  (require 'package)

  (setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                           ("gnu"       . "http://elpa.gnu.org/packages/")
                           ("melpa"     . "http://melpa.milkbox.net/packages/")
                           ("tromey"    . "http://tromey.com/elpa/")
                           ("marmalade" . "http://marmalade-repo.org/packages/")))
#+END_SRC

   While we can now do a =package-list-packages=, you can install and
   everything is good, however, we can't =require= any of these
   packages (in order to customize them in this file) until we do
   this:

#+BEGIN_SRC elisp
  (package-initialize)
#+END_SRC

** Installing Extra Packages

   Not sure why the package management system doesn't come with a
   programmatic way to specify what packages should be installed. Oh
   yeah, this is pretty new. Looks like everyone just rolls there own,
   so this is mine.

#+BEGIN_SRC elisp
  (defun packages-install (packages)
    (dolist (it packages)
      (when (not (package-installed-p it))
        (if (y-or-n-p (format "Package '%s' not found on system. Install?" it))
            (package-install it))))
    (delete-other-windows))
#+END_SRC

   This means that at any point in my configuration file, I can
   specify a list of packages to make sure they are installed.

#+BEGIN_SRC elisp
  (packages-install
                 '(auto-complete
                   circe
                   color-theme
                   color-theme-sanityinc-tomorrow
                   dired-details
                   epl
                   expand-region
                   flycheck
                   flycheck-color-mode-line
                   flyspell
                   git-commit-mode
                   git-gutter-fringe
                   gitconfig-mode
                   gitignore-mode
                   graphviz-dot-mode
                   iy-go-to-char
                   key-chord
                   mac-key-mode
                   magit
                   markdown-mode
                   multiple-cursors
                   nlinum
                   smart-mode-line
                   ;; redo+             ;; If not installed, edit mac-key-mode
                   smex
                   undo-tree
                   visual-regexp
                   yasnippet))
#+END_SRC

** Package Verification

   The =(require)= is a problem if the library isn't available, and if
   it isn't available, then this file dies and doesn't complete.
   Seems like it would be nice to wrap the configuration of a package
   in a block that is ignored if the package isn't available.

   The following code was found [[http://stackoverflow.com/questions/7790382/how-to-determine-whether-a-package-is-installed-in-elisp][in this discussion]], but I believe
   I'll be phasing this out now that I can simply install a long list
   of packages when I start.

#+BEGIN_SRC elisp
  (defun autofeaturep (feature)
    "For a feature symbol 'foo, return a result equivalent to:
  (or (featurep 'foo-autoloads) (featurep 'foo))
  Does not support subfeatures."
    (catch 'result
      (let ((feature-name (symbol-name feature)))
        (unless (string-match "-autoloads$" feature-name)
          (let ((feature-autoloads (intern-soft (concat feature-name "-autoloads"))))
            (when (and feature-autoloads (featurep feature-autoloads))
              (throw 'result t))))
        (featurep feature))))
#+END_SRC

** Variables

   General settings about me that other packages can use. The biggest
   problem is guessing my email address based on what computer I am using:

#+BEGIN_SRC elisp
  (if (equal "howard.abrams" user-login-name)
      (setq user-mail-address "howard.abrams@workday.com")
    (setq user-mail-address "howard.abrams@gmail.com"))
#+END_SRC

*** Tabs vs Spaces

   I have learned to distrust tabs in my source code, so let's make
   sure that we only have spaces.

#+BEGIN_SRC elisp
  (setq-default indent-tabs-mode nil)
  (setq tab-width 2)
#+END_SRC

*** Window Size

   Hrm ... I'm always increasing the window size, so I might as well
   just have it default to the size I want:

#+BEGIN_SRC elisp
(add-to-list 'default-frame-alist '(height . 46))
(add-to-list 'default-frame-alist '(width . 80))
#+END_SRC

   The bell is pretty obnoxious when it dings during scrolling.

#+BEGIN_SRC elisp
(setq ring-bell-function 'ignore)
#+END_SRC
** Display Settings

   I've been using Emacs for many years, and appreciate a certain
   minimalist approach to its display. While you can turn these off
   with the menu items now, it is just as easy to set them here.

#+BEGIN_SRC elisp
  (setq initial-scratch-message "") ;; Uh, I know what Scratch is for
  (setq visible-bell t)             ;; Get rid of the beeps
  (scroll-bar-mode 0)               ;; Scrollbars are wasted screen estate
  (tool-bar-mode 0)                 ;; Toolbars were only cool with XEmacs
  (menu-bar-mode 0)                 ;; No menus... especially in text mode
#+END_SRC

   Note: I often want Emacs in fullscreen, and this is the way:

#+BEGIN_SRC elisp :tangle no
  toggle-frame-fullscreen)
#+END_SRC

** Font Settings

   I love syntax highlighting.

#+BEGIN_SRC elisp
  (global-font-lock-mode 1)
#+END_SRC

   Specify the default font as =Source Code Pro=, which should already
   be [[http://blogs.adobe.com/typblography/2012/09/source-code-pro.html][downloaded]] and installed.

#+BEGIN_SRC elisp
  (when (window-system)
    (set-frame-font "Source Code Pro")
    (set-face-attribute 'default nil :font "Source Code Pro" :height 140)
    (set-face-font 'default "Source Code Pro"))
#+END_SRC

   While I do like the =Anonymous Pro= font (and usually have it download and
   installed), I don't like it as much.

#+BEGIN_SRC elisp :tangle no
  (when (window-system)
    (set-default-font "Anonymous Pro")
    (set-face-attribute 'default nil :font "Anonymous Pro" :height 140)
    (set-face-font 'default "Anonymous Pro"))
#+END_SRC

** Line Numbers

   Do you want line numbers on the left side:

#+BEGIN_SRC elisp
  (line-number-mode 1)
#+END_SRC

** Color Theme

   Use the color theme project by following [[http://www.nongnu.org/color-theme/][these instructions]].
   We now can do =M-x color-theme-<TAB> RET=

#+BEGIN_SRC elisp
  (require 'color-theme)
#+END_SRC

   The color themes work quite well, except they don't know about the
   org-mode source code blocks, so we need to set up a couple
   functions that we can use to set them.

#+BEGIN_SRC elisp
  (defun org-src-color-blocks-light ()
    "Colors the block headers and footers to make them stand out more for lighter themes"
    (interactive)
    (custom-set-faces
     '(org-block-begin-line 
      ((t (:underline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF"))))
     '(org-block-background
       ((t (:background "#FFFFEA"))))
     '(org-block-end-line
       ((t (:overline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))))

     ;; Looks like the minibuffer issues are only for v23
     ; (set-face-foreground 'minibuffer "black")
     ; (set-face-foreground 'minibuffer-prompt "red")
  )
  
  (defun org-src-color-blocks-dark ()
    "Colors the block headers and footers to make them stand out more for dark themes"
    (interactive)
    (custom-set-faces
     '(org-block-begin-line 
       ((t (:foreground "#008ED1" :background "#002E41"))))
     '(org-block-background
       ((t (:background "#111111"))))
     '(org-block-end-line
       ((t (:foreground "#008ED1" :background "#002E41")))))
  
     ;; Looks like the minibuffer issues are only for v23
     ; (set-face-foreground 'minibuffer "white")
     ; (set-face-foreground 'minibuffer-prompt "white")
  )
#+END_SRC

   My main reason for wanting to use the color theme project is to
   switch between /black on white/ during the day, and /white on
   black/ at night.

#+BEGIN_SRC elisp
  (defun color-theme-my-default ()
    "Tries to set up a normal color scheme"
    (interactive)
    (color-theme-sanityinc-tomorrow-day)
    (org-src-color-blocks-light))
  
  ;; During the day, we use the "standard" theme:
  (global-set-key (kbd "<f9> d") 'color-theme-my-default)
  
  ;; A good late-night scheme that isn't too harsh
  (global-set-key (kbd "<f9> l") (lambda () (interactive)
                                   (color-theme-sanityinc-tomorrow-eighties)
                                   (org-src-color-blocks-dark)))
  
  ;; Programming late into the night
  (global-set-key (kbd "<f9> m") (lambda () (interactive)
                                   (color-theme-sanityinc-tomorrow-bright)
                                   (org-src-color-blocks-dark)))
  
  ;; Too harsh? Use the late night theme
  (global-set-key (kbd "<f9> n") (lambda () (interactive)
                                   (color-theme-sanityinc-tomorrow-night)
                                   (org-src-color-blocks-dark)))
#+END_SRC

** Macintosh

   I like the ability to use the Command key to turn a standard Emacs
   into a more Macintosh-specific application. (See [[http://stackoverflow.com/questions/162896/emacs-on-mac-os-x-leopard-key-bindings][these online notes]])

#+BEGIN_SRC elisp
  (when (eq system-type 'darwin)
    (setq mac-option-modifier 'meta)
  
    ;; Aquamacs-specific code:
    (when (boundp 'aquamacs-version)
      (global-set-key [(alt k)] 'nlinum-mode))
    
    ;; Emacs on Mac specific code:
    (unless (boundp 'aquamacs-version)
      ;; Since I already have Command-V for pasting, I
      ;; don't need Ctrl-V to do that, so disable CUA:
      (cua-mode -1)
      
      (require 'mac-key-mode)
      (mac-key-mode 1)
      
      (define-key mac-key-mode-map [(alt o)] 'ido-find-file)

      ;; I'd rather selectively bind Meta-I to my italics function,
      ;; instead of showing the file in the Finder.
      (define-key mac-key-mode-map (kbd "A-i") nil)
      (define-key mac-key-mode-map [(alt 2)] 'mac-key-show-in-finder)
  
      (define-key mac-key-mode-map [(alt +)] 'text-scale-increase)
      (define-key mac-key-mode-map [(alt _)] 'text-scale-decrease)
      (define-key mac-key-mode-map [(alt l)] 'goto-line)
      (define-key mac-key-mode-map [(alt w)] 'delete-single-window)
      (define-key mac-key-mode-map [(alt m)] 'toggle-meta-key)
      (define-key mac-key-mode-map [(alt k)] 'nlinum-mode))
#+END_SRC

   Since the default ls for the Mac isn't so good, I always have the
   GNU ls version available in =/usr/local/bin/gls=.

#+BEGIN_SRC elisp
    (require 'ls-lisp)
    (setq ls-lisp-use-insert-directory-program t)
    (setq insert-directory-program "/usr/local/bin/gls"))
#+END_SRC

   I hate the default implementation of Command-M. Now,
   pressing Command-M will toggle whether the Option key is a
   standard Option key or a Meta key:

#+BEGIN_SRC elisp
  (defun toggle-meta-key ()
    "Toggles whether the Mac option key is an option key or a meta key."
    (interactive)
    (if (eq mac-option-modifier 'meta)
        (setq mac-option-modifier nil)
      (setq mac-option-modifier 'meta)))
#+END_SRC

   I would like Command-W to close a frame, but only if it only has a
   single window in it. I found this code on [[http://www.emacswiki.org/emacs/frame-cmds.el][this site]].

#+BEGIN_SRC elisp
  (defun delete-single-window (&optional window)
    "Remove WINDOW from the display.  Default is `selected-window'.
  If WINDOW is the only one in its frame, then `delete-frame' too."
    (interactive)
    (save-current-buffer
      (setq window (or window (selected-window)))
      (select-window window)
      (kill-buffer)
      (if (one-window-p t) 
          (delete-frame) 
          (delete-window (selected-window)))))
#+END_SRC

*** Skype

    I normally mute Skype with some Alfred keystroke running some
    AppleScript. However, Emacs will grab all keystrokes before
    passing them on, so I need this function:

#+BEGIN_SRC elisp
   (defun mute-skype ()
     "Mutes or unmutes Skype via an AppleScript call."
     (interactive)
     (let ((mute-script "tell application \"Skype\"
    if \(send command \"GET MUTE\" script name \"MuteToggler\"\) is equal to \"MUTE ON\" then
      send command \"SET MUTE OFF\" script name \"MuteToggler\"
    else
      send command \"SET MUTE ON\" script name \"MuteToggler\"
    end if
  end tell"))
       (progn
         (call-process "osascript" nil nil nil "-ss" "-e" mute-script)
         (message "Skype (un)mute message has been sent."))))
  
  (global-set-key (kbd "C-M-A-m") 'mute-skype)
#+END_SRC

*** Undo and Redo

    According to [[http://ergoemacs.org/emacs/emacs_best_redo_mode.html][this article]], I get better functionality than the
    =redo+= plugin (which I can't seem to get working well).

#+BEGIN_SRC elisp
  (require 'undo-tree)
  (global-undo-tree-mode 1)
  (defalias 'redo 'undo-tree-redo)

  (when (eq system-type 'darwin)
    (unless (boundp 'aquamacs-version)
      (define-key mac-key-mode-map [(alt z)] 'undo-tree-undo)
      (define-key mac-key-mode-map [(alt S-z)] 'undo-tree-redo)))

  (global-set-key (kbd "C-z") 'undo) ; Zap to character isn't helpful
  (global-set-key (kbd "C-S-z") 'redo)
#+END_SRC

** More Key Definitions

   Clearly, the most important keybindings are the function keys,
   right? Here is my list of needs:

   - *F1* - Help? Isn't Control-H good enough?
   - *F2* - Standard alternate meta key with lots of bindings
   - *F3* - Define a keyboard macro
   - *F4* - Replay a keyboard macro
   - *F5* - Slime-JS REPL
   - *F6* - Setup window or move forward with demonstration.
   - *F7* - Switch to another window
   - *F8* - Switch to buffer
   - *F9* - My other meta key for changing colors and other odd
     bindings that I actually don't use that often

#+BEGIN_SRC elisp
  (global-set-key (kbd "<f6>") 'setup-windows)
  (global-set-key (kbd "<f7>") 'other-window)
  (global-set-key (kbd "<f8>") 'ido-switch-buffer)
#+END_SRC

   Change window configuration and then return to the old
   configuration with [[http://www.emacswiki.org/emacs/WinnerMode][winner-mode]].  Use =Control-C Arrow= keys to
   cycle through window/frame configurations.

#+BEGIN_SRC elisp
  (winner-mode 1)
#+END_SRC

** Key Chords

   Key Chords allows you to use any two keys pressed at the same time
   to trigger a function call. Interesting possibilities, but of
   course, you don't want it to make any mistakes.

   Like 'xo' seemed good for 'other-window' until I needed to type
   the word, 'ox'.

   I like vi's =.= command, where it quickly repeats the last command
   you did. Emacs has similar functionality, but I never remember
   =C-x z=, so let's map it to something else.

#+BEGIN_SRC elisp
  (if (autofeaturep 'key-chord)
      (progn
        (require 'key-chord)
        (key-chord-mode +1)
  
        (key-chord-define-global ",." 'repeat)
        (key-chord-define-global "qw" 'query-replace)
        (key-chord-define-global "xb" 'ido-switch-buffer)
        (key-chord-define-global "xf" 'ido-find-file)
  
        (if (autofeaturep 'iy-go-to-char)
            (progn
              (require 'iy-go-to-char)
  
              (key-chord-define-global "fg" 'iy-go-to-char)
              (key-chord-define-global "df" 'iy-go-to-char-backward)))))
#+END_SRC

   The [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]] project allows a quick search for a particular
   character. In [[http://www.youtube.com/watch?v%3DNXTf8_Arl1w][Episode 6]] of [[http://www.emacsrocks.com][EmacsRocks]], [[http://twitter.com/emacsrocks][Magnar Sveen]] pulls it all
   together and makes a compelling case for micro-optimizations.
   We'll see if I can remember to use the feature.

** Recent File List

   According to [[http://www.emacswiki.org/emacs-es/RecentFiles][this article]], Emacs already has the recent file
   listing available, just not turned on.

#+BEGIN_SRC elisp
  (require 'recentf)
  (recentf-mode 1)
  (setq recentf-max-menu-items 25)
  (global-set-key (kbd "C-x C-r") 'recentf-open-files)
#+END_SRC

** Multiple Cursors

   While I'm not sure how often I will use [[https://github.com/emacsmirror/multiple-cursors][multiple-cursors]] project,
   I'm going to try to remember it is there. It doesn't have any
   default keybindings, so I set up the suggested:

#+BEGIN_SRC elisp
  (if (autofeaturep 'multiple-cursors)
        (progn
          (require 'multiple-cursors)
          (global-set-key (kbd "C->") 'mc/mark-next-like-this)
          (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
          (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)))
#+END_SRC

** Auto Complete

   This feature scans the code and suggests completions for what you
   are typing. Useful at times ... annoying at others.

#+BEGIN_SRC elisp
  (require 'auto-complete-config)
  (add-to-list 'ac-dictionary-directories "~/.emacs.d/ac-dict")

  (set-default 'ac-sources
               '(ac-source-abbrev
                 ac-source-dictionary
                 ac-source-yasnippet
                 ac-source-words-in-buffer
                 ac-source-words-in-same-mode-buffers
                 ac-source-semantic))

  (ac-config-default)
  (global-auto-complete-mode t)
#+END_SRC

   Note that we specify where a dictionary lives for each specific
   language, and if for some reason, a mode isn't getting the "AC"
   minor mode, you can add to it with this magic:

#+BEGIN_SRC elisp :tangle off
  (dolist (m '(python-mode js2-mode clojure-mode))
    (add-to-list 'ac-modes m))
#+END_SRC

** Abbreviation Mode

   Using the built-in [[http://www.emacswiki.org/emacs/AbbrevMode][Abbreviation Mode]], but setting it up only for
   the text modes:

#+BEGIN_SRC elisp
(add-hook 'text-mode-hook (lambda () (abbrev-mode 1)))
#+END_SRC

   While you can make abbreviations in situ, I figured I should
   /pre-load/ a bunch that I use:

#+BEGIN_SRC elisp
  (define-abbrev-table 'global-abbrev-table 
    '(("HA" "Howard Abrams")
      ("WD" "Workday")
      ("btw" "by the way")
      ("func" "function")
      ("note" "*Note:*")
      ("OS" "OpenStack")
      ("NG" "AngularJS")
      ("JS" "JavaScript")
      ("CS" "CoffeeScript")))
#+END_SRC

   This allows me to write =os= as =OpenStack=, and if I want to write
   =os=, I just don't put a space or some punctuation behind it. The
   trick, however, is remembering what works.

   *Note:* Capitalizing the first letter, i.e. =Btw=, expands the
   abbreviation with an initial capital, i.e. =By the way= ... Sweet.

** Yas Snippet

   The [[https://github.com/capitaomorte/yasnippet][yasnippet project]] allows me to create snippets of code that
   can be brought into a file, based on the language. 

#+BEGIN_SRC elisp
  (require 'yasnippet)
  (yas-global-mode 1)
#+END_SRC

   Inside the =snippets= directory should be directories for each
   mode, e.g.  =clojure-mode= and =org-mode=. This connects the mode
   with the snippets.

#+BEGIN_SRC elisp
  (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")
#+END_SRC

   [[https://code.google.com/p/js2-mode/][js2-mode]] is good, but its name means that Yas' won't automatically
   link it to its =js-mode=. This little bit of magic does the linking:

#+BEGIN_SRC elisp
  (add-hook 'js2-mode-hook '(lambda ()
                              (make-local-variable 'yas-extra-modes)
                              (add-to-list 'yas-extra-modes 'js-mode)
                              (yas-minor-mode 1)))
#+END_SRC

** Dash

   The [[http://kapeli.com/][Dash product]] is nice, and [[https://github.com/Kapeli/dash-at-point][this project]] allows Emacs to open
   Dash for documentation of anything with a =C-c d= keystroke:

#+BEGIN_SRC elisp
  (autoload 'dash-at-point "dash-at-point"
            "Search the word at point with Dash." t nil)
  (global-set-key (kbd "C-c d") 'dash-at-point)
#+END_SRC

   Note: I checked out the code elsewhere, and created a symlink from
   my =~/.emacs.d= directory to the =dash-as-point.el= file.

** Note Grep

   First, we need to have the =find-grep= ignore =.git= directories
   and search for wholewords:

#+BEGIN_SRC elisp
  (setq grep-find-command 
        "find . -type f '!' -wholename '*/.git/*' -print0 | xargs -0 -e grep -nHPi -e ")
  (setq rep-highlight-matches t)
#+END_SRC

   I use the standard [[http://emacswiki.org/emacs/GrepMode#toc1][grep package]] in Emacs and wrap it so that I
   can easily search through my notes. However, I'm using a later
   version of Gnu Grep. On Mac OS X, run these two commands:

#+BEGIN_EXAMPLE
brew tap homebrew/dupes
brew install homebrew/dupes/grep
#+END_EXAMPLE

   Now we can call the =ggrep= command:

#+BEGIN_SRC elisp
  (defun ngrep (reg-exp)
    "Searches the Notes and ORG directory tree for an expression.
  The pipe symbol separates an org-mode tag from the phrase to search,
  e.g. jquery|appendTo searches only the files with a 'jquery' tag."
    (interactive "sSearch note directories: ")
    (let ((search-dir "~/Notes ~/Technical")
          (options "--line-number --with-filename --word-regexp --ignore-case")
          (the-args (split-string reg-exp "\|")))
      (if (> (length the-args) 1)
          (let* ((the-tag (car the-args))
                 (reg-exp (combine-and-quote-strings (cdr the-args)))
                 (files   (split-string (shell-command-to-string
                               (concat
                                "grep -r --files-with-matches '#+TAGS: .*"
                                the-tag "' " search-dir)) "\n")))
            (progn
              (message "Searching for %s with tag of %s" reg-exp the-tag)
              (grep-find (concat "grep " options " " reg-exp " "
                                 (combine-and-quote-strings files)))))
        (let* ((file-exts '( "*.org" "*.md" "*.txt" "*.markdown"))
               (file-types (mapconcat (function (lambda (x) (concat "--include '" x "'")))  file-exts " ")))
          (progn
            (message "Searching in %s" search-dir)
            (grep-compute-defaults)
            (grep-find (concat "grep -r -e " reg-exp " " options " "
                               file-types " " search-dir)))))))
  
  (global-set-key (kbd "C-x C-n") 'ngrep)
  ;; (global-set-key (kbd "C-x C-r") 'rgrep)
#+END_SRC

   Don't forget that after doing a =C-x C-f= to find a file, you can
   hit another =M-f= to do a find the given directory (and subs).

   Also, you can do a full locate with =C-x C-l=:

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-x C-l") 'locate)
  (setq locate-command "mdfind")  ;; Use Mac OS X's Spotlight
#+END_SRC

** Spell Checking

   I like spell checking with [[http://www.emacswiki.org/emacs/FlySpell][FlySpell]], which uses =ispell=.

   To build a dictionary hash (seems important now), do this:

#+BEGIN_SRC sh :tangle no
  touch ~/.dictionary.txt
  buildhash ~/.dictionary.txt /usr/local/lib/english.aff ~/.dictionary.txt.hash
#+END_SRC

   Then, we can use it like:

#+BEGIN_SRC elisp
  (setq ispell-personal-dictionary
      (concat (getenv "HOME") "/.dictionary.txt"))

  (dolist (hook '(text-mode-hook org-mode-hook))
    (add-hook hook (lambda () (flyspell-mode 1))))
#+END_SRC

   If I find any =text-mode= derived mode that I don't want to
   spell-check, then I need to use the following:

#+BEGIN_SRC elisp :tangle no
  (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
    (add-hook hook (lambda () (flyspell-mode -1))))
#+END_SRC

** Miscellaneous Settings

*** IDO (Interactively DO Things)

    According to [[http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/][Mickey]], IDO is the greatest thing.

#+BEGIN_SRC elisp
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode 1)
#+END_SRC

    According to [[https://gist.github.com/rkneufeld/5126926][Ryan Kneufeld]], we could make IDO work
    vertically, which is much easier to read.

#+BEGIN_SRC elisp
(setq ido-decorations                                                      ; Make ido-mode display vertically
      (quote
       ("\n-> "           ; Opening bracket around prospect list
        ""                ; Closing bracket around prospect list
        "\n   "           ; separator between prospects
        "\n   ..."        ; appears at end of truncated list of prospects
        "["               ; opening bracket around common match string
        "]"               ; closing bracket around common match string
        " [No match]"     ; displayed when there is no match
        " [Matched]"      ; displayed if there is a single match
        " [Not readable]" ; current diretory is not readable
        " [Too big]"      ; directory too big
        " [Confirm]")))   ; confirm creation of new file or buffer
 
(add-hook 'ido-setup-hook                                                  ; Navigate ido-mode vertically
          (lambda ()
            (define-key ido-completion-map [down] 'ido-next-match)
            (define-key ido-completion-map [up] 'ido-prev-match)
            (define-key ido-completion-map (kbd "C-n") 'ido-next-match)
            (define-key ido-completion-map (kbd "C-p") 'ido-prev-match)))
#+END_SRC

    I guess you can call =ido-use-url-at-point= with Markdown to jump
    to the URLs. Perhaps?

*** SMEX

    Built using [[*IDO%20(Interactively%20DO%20Things)][IDO]].

#+BEGIN_SRC elisp :tangle no
  (require 'smex)
  (smex-initialize) ; Can be omitted. This might cause a (minimal) delay

  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)

  ;; This is our old M-x.
  (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
#+END_SRC

*** Backup Settings

    This setting moves all backup files to a central location.
    Got it from [[http://whattheemacsd.com/init.el-02.html][this page]].

#+BEGIN_SRC elisp
  (setq backup-directory-alist
        `(("." . ,(expand-file-name
                   (concat user-emacs-directory "backups")))))
#+END_SRC

   Make backups of files, even when they're in version control

#+BEGIN_SRC elisp
  (setq vc-make-backup-files t)
#+END_SRC

*** Line Numbers

    Turn =nlinum-mode= on/off with =Command-K= (see the [[*Macintosh][Macintosh]]
    section above).  However, turn this on automatically for
    programming modes?

#+BEGIN_SRC elisp
  (add-hook 'prog-mode-hook 'nlinum-mode)
#+END_SRC

*** Smart Scan

    Use the =M-n= to search the buffer for the word the cursor is
    currently pointing. =M-p= to go backwards.

#+BEGIN_SRC elisp
  (load-library "smart-scan")
#+END_SRC
*** Dired Options

    The associated group name isn't too useful when viewing the dired output.

#+BEGIN_SRC elisp
  (setq dired-listing-switches "-alGh")
#+END_SRC

    This enhancement to dired hides the ugly details until you hit
    '(' and shows the details with ')'. I also change the [...] to a
    simple asterisk.

#+BEGIN_SRC elisp
  (require 'dired-details)
  (dired-details-install)
  (setq dired-details-hidden-string "* ")
#+END_SRC

*** Save Place

    The [[http://www.emacswiki.org/emacs/SavePlace][Save Place]] mode will... well, save your place in between
    Emacs sessions.

#+BEGIN_SRC elisp
  (require 'saveplace)
  (setq-default save-place t)
#+END_SRC

*** Uniquify

    Get rid of silly <1> and <2> to buffers with the same file name,
    using [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html][uniquify]].

#+BEGIN_SRC elisp
  (require 'uniquify)
#+END_SRC

*** Expand Region

    Wherever you are in a file, and whatever the type of file, you
    can slowly increase a region selection by logical segments.

#+BEGIN_SRC elisp
  (if (autofeaturep 'expand-region)
      (progn
        (require 'expand-region)
        (global-set-key (kbd "C-=") 'er/expand-region)))
#+END_SRC

*** Smart Mode Line

    I like the cleanliness of the [[https://github.com/Bruce-Connor/smart-mode-line][Smart Mode Line]]:

#+BEGIN_SRC elisp
  (require 'smart-mode-line)
  (if after-init-time (sml/setup)
    (add-hook 'after-init-hook 'sml/setup))

  (custom-set-variables '(sml/active-background-color "dark blue"))
#+END_SRC

    Especially since you can limit the pathname of the displayed
    filename.

#+BEGIN_SRC elisp
  (add-to-list 'sml/replacer-regexp-list '("^~/Google Drive/" ":Goo:"))
  (add-to-list 'sml/replacer-regexp-list '("^~/Other/dot-files" ":.:"))
  (add-to-list 'sml/replacer-regexp-list '("^~/Work/wpc-api/server/" ":API:"))
  (add-to-list 'sml/replacer-regexp-list '("^~/Work/wpc-fai/ci/" ":CI:"))
#+END_SRC

    Hiding some Minor modes in the mode line is real swell. This
    leaves the mode-line with only important stuff.

#+BEGIN_SRC elisp
  (add-to-list 'sml/hidden-modes " GitGutter")
  (add-to-list 'sml/hidden-modes " Undo-Tree")
#+END_SRC

*** Better Searching and Visual Regular Expressions

    Only after you've started an =isearch-forward= do you wish you had
    regular expressions available, so why not just switch those defaults?

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-set-key (kbd "C-M-s") 'isearch-forward)
  (global-set-key (kbd "C-M-r") 'isearch-backward)
#+END_SRC

    The [[https://github.com/benma/visual-regexp.el][Visual Regular Expressions]] project highlights the matches
    while you try to remember the differences between Perl's regular
    expressions and Emacs'...

    Begin with =C-c r= then type the regexp. To see the highlighted
    matches, type =C-c a= before you hit 'Return' to accept it.

#+BEGIN_SRC elisp
  (require 'visual-regexp)
  (define-key global-map (kbd "C-c r") 'vr/replace)
  (define-key global-map (kbd "C-c q") 'vr/query-replace)
  
  ;; if you use multiple-cursors, this is for you:
  (define-key global-map (kbd "C-c m") 'vr/mc-mark)
#+END_SRC

*** Flycheck

    [[https://github.com/flycheck/flycheck][Flycheck]] seems to be quite superior to good ol' Flymake.

#+BEGIN_SRC elisp
(require 'flycheck)

(add-hook 'after-init-hook #'global-flycheck-mode)
#+END_SRC

    The most interesting aspect is that it doesn't support Clojure.

* Org Mode

  The [[http://orgmode.org][Org Mode]] feature was a big reason in my recent re-kindling of my
  Emacs love affair. Make sure the latest packages are installed:

#+BEGIN_SRC elisp
  (packages-install '( org
                       org-mime
                       org-journal
                       org-presie
                       plantuml-mode
                       ox-reveal ))
#+END_SRC

** Initial Settings

   Initialization of Org Mode by hooking it into YASnippets, which
   should allow me to easily add templates to my files.

#+BEGIN_SRC elisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (yas/minor-mode-on)))
#+END_SRC

** Journaling

   Didn't realize that [[http://www.emacswiki.org/emacs/OrgJournal][org-journal]] essentially does what I have been
   doing by hand. With a little customization, I don't have to change
   anything else:

#+BEGIN_SRC elisp
  (if (autofeaturep 'org-journal)
      (progn
        (require 'org-journal)
        (setq org-journal-dir "~/journal/")))
#+END_SRC

   All my journal entries will be formatted using org-mode:

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '(".*/[0-9]*$" . org-mode))
#+END_SRC

   The date format is essentially, the top of the file.

#+BEGIN_SRC elisp
  (setq org-journal-date-format "#+TITLE: Journal Entry- %Y-%m-%d (%A)")
#+END_SRC

   The time format is the heading for each section. I will set it to a
   blank since I really don't care about the time I add a section.

#+BEGIN_SRC elisp
  (setq org-journal-time-format "")
#+END_SRC

    A function to easily load today (and yesterday's) journal entry.

#+BEGIN_SRC elisp
  (defun journal-file-today ()
    "Creates and load a file based on today's date."
    (interactive)
    (let ((daily-name (format-time-string "%Y%m%d")))
      (find-file (expand-file-name
                  (concat "~/journal/" daily-name)))))
#+END_SRC

    Since I sometimes (not often) forget to create 

#+BEGIN_SRC elisp
  (defun journal-file-yesterday ()
    "Creates and load a file based on yesterday's date."
    (interactive)
    (let ((daily-name (format-time-string "%Y%m%d"
       (time-subtract (current-time) (days-to-time 1)))))
      (find-file (expand-file-name
                  (concat "~/journal/" daily-name)))))
#+END_SRC

I really would really like to read what I did last year "at this
time", and by that, I mean, 365 days ago, plus or minus a few to get
to the same day of the week.

#+BEGIN_SRC elisp
  (defun journal-last-year-file ()
    "Returns the string corresponding to the journal entry that
  happened 'last year' at this same time (meaning on the same day
  of the week)."
  (let* ((last-year-seconds (- (float-time) (* 365 24 60 60)))
         (last-year (seconds-to-time last-year-seconds))
         (last-year-dow (nth 6 (decode-time last-year)))
         (this-year-dow (nth 6 (decode-time)))
         (difference (if (> this-year-dow last-year-dow)
                         (- this-year-dow last-year-dow)
                       (- last-year-dow this-year-dow)))
         (target-date-seconds (+ last-year-seconds (* difference 24 60 60)))
         (target-date (seconds-to-time target-date-seconds)))
    (format-time-string "%Y%m%d" target-date)))
  
  (defun journal-last-year ()
    "Loads last year's journal entry, which is not necessary the
  same day of the month, but will be the same day of the week."
    (interactive)
    (let ((journal-file (concat org-journal-dir (journal-last-year-file))))
      (find-file journal-file)))
  #+END_SRC
    
*** Org-Mode Sprint Note Files

    At the beginning of each sprint, we need to set this to the new
    sprint file.

#+BEGIN_SRC elisp
  (setq current-sprint "2014-02")
  
  (defun current-sprint-file ()
    (expand-file-name (concat "~/Notes/Sprint-" current-sprint ".org")))
  
  (defun get-current-sprint-file ()
    "Loads up the org-mode note associated with my current sprint."
    (interactive)
    (find-file (current-sprint-file)))
#+END_SRC

*** Taking Meeting Notes

    I've notice that while I really like taking notes in a meeting, I
    don't always like the multiple windows I have opened, so I created
    this function that I can easily call to eliminate distractions
    during a meeting.

#+BEGIN_SRC elisp
(defun meeting-notes ()
  "Call this after creating an org-mode heading for where the notes for the meeting
should be. After calling this function, call 'meeting-done' to reset the environment."
  (interactive)
  (outline-mark-subtree)                              ;; Select org-mode section
  (narrow-to-region (region-beginning) (region-end))  ;; Only show that region
  (deactivate-mark)
  (delete-other-windows)                              ;; Get rid of other windows
  (text-scale-set 2)                                  ;; Text is now readable by others
  (global-set-key (kbd "<f6>") 'meeting-done)
  (message "When finished taking your notes, press <F6>"))
#+END_SRC

    Of course, I need an 'undo' feature when the meeting is over...

#+BEGIN_SRC elisp
(defun meeting-done ()
  "Attempt to 'undo' the effects of taking meeting notes."
  (interactive)
  (widen)                                       ;; Opposite of narrow-to-region
  (text-scale-set 0)                            ;; Reset the font size increase
  (winner-undo))                                ;; Put the windows back in place
#+END_SRC

*** Recent and Heavily Used Files

    Daily note-taking goes into my sprint file notes, so this makes a
    global short-cut key.

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-x C-u") 'get-current-sprint-file)
#+END_SRC

*** Org-Mode Colors

  Before we load =org-mode= proper, we need to set the following
  syntax high-lighting parameters. These are used to help bring out
  the source code during literate programming mode.

  This information came from [[http://orgmode.org/worg/org-contrib/babel/examples/fontify-src-code-blocks.html][these instructions]], however, they tend
  to conflict with the /color-theme/, so we'll turn them off for now.

#+BEGIN_SRC elisp
  (defface org-block-begin-line
    '((t (:underline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
    "Face used for the line delimiting the begin of source blocks.")
  
  (defface org-block-background
    '((t (:background "#FFFFEA")))
    "Face used for the source block background.")
  
  (defface org-block-end-line
    '((t (:overline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF")))
    "Face used for the line delimiting the end of source blocks.")
#+END_SRC

** Library Loading

   The standard package manager (and most recent versions of Emacs)
   include =org-mode=, however, I want the latest version that has
   specific features for literate programming.

   Org-mode is installed in the global directory.

#+BEGIN_SRC elisp
  (require 'org)
  (require 'ob-tangle)
#+END_SRC

** Global Key Bindings

   The =org-mode= has some useful keybindings that are helpful no
   matter what mode you are using currently.

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c b") 'org-iswitchb)

  (global-set-key (kbd "C-M-|") 'indent-rigidly)
#+END_SRC

** Local Key Bindings

   A couple of short-cut keys to make it easier to edit text.

#+BEGIN_SRC elisp
  (defun org-text-wrapper (txt &optional endtxt)
    "Wraps the region with the text passed in as an argument."
    (if (use-region-p)
        (save-restriction
          (narrow-to-region (region-beginning) (region-end))
          (goto-char (point-min))
          (insert txt)
          (goto-char (point-max))
          (if endtxt
              (insert endtxt)
            (insert txt)))
      (if (looking-at "[A-z]")
          (save-excursion
            (if (not (looking-back "[     ]"))
                (backward-word))
            (progn
              (mark-word)
              (org-text-wrapper txt endtxt)))
        (progn
          (insert txt)
          (let ((spot (point)))
            (insert txt)
            (goto-char spot))))))
  
  (defun org-text-bold () "Wraps the region with asterisks."
    (interactive)
    (org-text-wrapper "*"))
  (defun org-text-italics () "Wraps the region with slashes."
    (interactive)
    (org-text-wrapper "/"))
  (defun org-text-code () "Wraps the region with equal signs."
    (interactive)
    (org-text-wrapper "="))
#+END_SRC

   Now we can associate some keystrokes to the org-mode:

#+BEGIN_SRC elisp
  (add-hook 'org-mode-hook
        (lambda ()
          (local-set-key (kbd "A-b") 'org-text-bold)
          (local-set-key (kbd "A-i") 'org-text-italics)
          (local-set-key (kbd "A-=") 'org-text-code)))
#+END_SRC

   When pasting certain kinds of links, the "text" may be obvious.

#+BEGIN_SRC elisp
  (defun org-generate-link-description (url description)
    (cond
     ((string-match "jira.workday" url)
      (replace-regexp-in-string "https://jira.+/browse/" "" url))
     ((string-match "crucible.workday" url)
      (replace-regexp-in-string "https://crucible.+/cru/" "" url))
     (t description)))

  (setq org-make-link-description-function 'org-generate-link-description)
#+END_SRC

   I'm often typing Jira entries that match a particular link pattern.

#+BEGIN_SRC elisp
  (defun jira-link (b e)
    "Wraps the region with an org-mode link."
    (interactive "r")
    (save-restriction
      (narrow-to-region b e)
      (let ((jiraid (buffer-substring (point-min) (point-max))))
        (goto-char (point-min))
        (insert "[[https://jira.workday.com/browse/" jiraid "][")
        (goto-char (point-max))
        (insert "]]"))))
#+END_SRC

** Speed Keys

   If point is at the beginning of a headline or code block in
   org-mode, single keys do fun things. See =org-speed-command-help=
   for details (or hit the ? key at a headline).

#+BEGIN_SRC elisp
  (setq org-use-speed-commands t)
#+END_SRC

** Specify the Org Directories

   I keep all my =org-mode= files in a few directories, and I would
   like them automatically searched when I generate agendas.

#+BEGIN_SRC elisp
(setq org-agenda-files '("~/Dropbox/org/personal" 
                         "~/Google Drive/technical" 
                         "~/Dropbox/org/project"))
#+END_SRC

** Auto Note Capturing

   Let's say you were in the middle of something, but would like to
   /take a quick note/, but without affecting the file you are
   working on. This is called a "capture", and is bound to the
   following key:

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-c c") 'org-capture)
#+END_SRC

   This will bring up a list of /note capturing templates/:

#+BEGIN_SRC elisp
  (setq org-capture-templates
        '(("n" "Thought or Note" entry (file "~/Technical/general-notes.org")
           "* %i%?\n    %a" :empty-lines 1)
  
          ("w" "General Sprint Note" entry (file+headline (current-sprint-file) "Work Issues")
           "*** %i%?" :empty-lines 1)
          ("m" "Meeting Notes" entry (file+headline (current-sprint-file) "Meeting Notes")
           "** %i%?\n\n   Met on %t: \n\n" :empty-lines 1)
          ("r" "Retrospective Status" entry (file+headline (current-sprint-file) "Status/Accomplishments")
           "*** %i%?\n  Linked: %a" :empty-lines 1)
          ("g" "Retrospective Goodness" entry (file+headline (current-sprint-file) "Keep Doing (Good)")
           "*** %i%?" :empty-lines 1)
          ("b" "Retrospective Badness" entry (file+headline (current-sprint-file) "Stop Doing (Bad)")
           "*** %i%?" :empty-lines 1)
          ("i" "Retrospective Improvement" entry (file+headline (current-sprint-file) "Start Doing (Improvements)")
           "*** %i%?" :empty-lines 1)
          ("x" "Note for Next Sprint" entry (file+headline (current-sprint-file) "Notes for Next Sprint")
           "*** %i%?" :empty-lines 1)
  
          ("p" "Personal Journal" entry (file+datetree "~/Technical/personal.org")
           "* Projects\n\n  %i%?\n\n  %a" :empty-lines 1)))
  
  ;; General notes go into this file:
  (setq org-default-notes-file "~/Technical/personal.org")
#+END_SRC

   After you have selected the template, you type in your note and hit
   =C-c C-c= to store it in the file listed above.

   Just remember, at some point to hit =C-c C-w= to /refile/ that note
   in the appropriate place.

** Checking Things Off

   When I check off an item as done, sometimes I want to add some
   details about the completion (this is really only helpful when I'm
   consulting). 

   With this setting, each time you turn an entry from a TODO state
   into the DONE state, a line 'CLOSED: [timestamp]' will be inserted
   just after the headline. If you turn the entry back into a TODO
   item through further state cycling, that line will be removed
   again.

#+BEGIN_SRC elisp
  ; (setq org-log-done 'time)
  (setq org-log-done 'note)
#+END_SRC

** Org Publishing

   The brilliance of =org-mode= is the ability to publish your notes
   as HTML files into a web server. See [[http://orgmode.org/worg/org-tutorials/org-publish-html-tutorial.html][these instructions]]. I've
   transitioned over to the new =ox= exporter, see [[http://orgmode.org/worg/org-8.0.html][these instructions]].

#+BEGIN_SRC elisp
  (require 'ox-html)
  
  (setq org-publish-project-alist  '(
    ("org-notes"
     :base-directory        "~/Technical/"
     :base-extension        "org"
     :publishing-directory  "~/Sites/"
     :recursive             t
     :publishing-function org-html-publish-to-html
     :headline-levels       4             ; Just the default for this project.
     :auto-preamble         t
     :auto-sitemap          t             ; Generate sitemap.org automagically...
     :makeindex             t
     :section-numbers       nil
     :table-of-contents     nil
     :style "<link rel=\"stylesheet\" href=\"../css/styles.css\" type=\"text/css\"/><link rel=\"stylesheet\" href=\"css/styles.css\" type=\"text/css\"/> <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\" type=\"text/javascript\"></script> <link href=\"http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/themes/smoothness/jquery-ui.css\" type=\"text/css\" rel=\"Stylesheet\" />    <script src=\"https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js\" type=\"text/javascript\"></script> <script =\"text/jacascript\" src=\"js/script.js\"></script>"
     )
  
    ("dot-files"
     :base-directory       "~/Work/dot-files/"
     :base-extension       "org"
     :publishing-directory "~/Work/dot-files/docs"
     :recursive            f
     :publishing-function org-html-publish-to-html
     :auto-preamble         t
     :auto-sitemap          t             ; Generate sitemap.org automagically...
     :makeindex             f
     :section-numbers       nil
     :table-of-contents     nil
     )

    ("org-static"
     :base-directory       "~/Dropbox/org/"
     :base-extension       "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
     :publishing-directory "~/Sites/"
     :recursive            t
     :publishing-function  org-publish-attachment
     )
  
    ("all" :components ("org-notes" "org-static" "dot-files"))))
#+END_SRC

   I really, really would like to affect the output of the
   exported/published HTML files to make them /prettier/.

#+BEGIN_SRC elisp
  (setq org-html-style "<link rel='stylesheet' href='http://www.howardism.org/styles/org-export-html-style.css' type='text/css'/>
  <script src='http://use.edgefonts.net/source-sans-pro.js'></script>
  <script src='http://use.edgefonts.net/source-code-pro.js'></script>")
#+END_SRC

*** Default Export Settings

    To make the =org-mode= export defaults closer to my liking
    (without having to put specific #+PROPERTY commands), start by
    =describe-variable= the =org-export-plist-vars= variable.

    This returns the list of variables that can be customized:

#+BEGIN_SRC elisp
  (setq org-export-with-section-numbers nil)
  (setq org-export-with-toc nil)
  (setq org-export-skip-text-before-1st-heading nil)

  (setq org-export-html-postamble nil) ;; don't need any gunk at end

  (setq org-export-creator-info nil)
  (setq org-export-email-info nil)
  (setq org-export-author-info nil)
  (setq org-export-time-stamp-file nil)
  (setq org-export-html-with-timestamp nil)
#+END_SRC

*** Publishing as Presentation

    Out of all [[http://orgmode.org/worg/org-tutorials/non-beamer-presentations.html][the ideas]] online, I prefer using [[http://meyerweb.com/eric/tools/s5/][S5]], and by loading
    [[https://github.com/eschulte/org-S5/blob/master/org-export-as-s5.el][this code]], we can issue =org-export-as-s5=:

#+BEGIN_SRC elisp
  (autoload 'org-export-as-s5 "org-export-as-s5"
            "Module extension for Presentations for Org-Mode." t nil)
#+END_SRC

    And let's tie this to a keystroke to make it easier to use:

#+BEGIN_SRC elisp
  (global-set-key (kbd "<f9> p") 'org-export-as-s5)
#+END_SRC

*** Publish as Markdown

    Using the [[http://orgmode.org/worg/org-contrib/org-export-generic.php][org-export-generic]] feature, we can export to Markdown
    using =C-c C-e g M=:

#+BEGIN_SRC elisp :tangle no
  (require 'org-export-generic)
  
  (org-set-generic-type
   "Markdown" 
   '(:file-suffix ".markdown"
     :key-binding ?M
     :title-format "%s\n"
     :title-suffix ?=
     :body-header-section-numbers t
     :body-header-section-number-format "%s) "
     :body-section-header-prefix ("\n## " "\n### " "\n#### " "\n##### " "\n###### ")
     :body-section-header-format  "%s"
     :body-section-header-suffix  "\n\n"
     :todo-keywords-export        t
     :body-line-format            "  %s\n"
     :body-tags-export            t
     :body-tags-prefix            " <tags>"
     :body-tags-suffix            "</tags>\n"
     ;;:body-section-prefix       "<secprefix>\n"
     ;;:body-section-suffix       "</secsuffix>\n"
     :body-line-export-preformated        t
     :body-line-fixed-prefix      "<pre>\n"
     :body-line-fixed-suffix      "\n</pre>\n"
     :body-line-fixed-format      "%s\n"
     :body-list-prefix            "\n"
     :body-list-suffix            "\n"
     :body-list-format            "  * %s\n"
     ;;:body-number-list-prefix   "<ol>\n"
     ;;:body-number-list-suffix   "</ol>\n"
     ;;:body-number-list-format   "<li>%s</li>\n"
     ;;:body-number-list-leave-number     t
     :body-list-checkbox-todo     "[_] "
     :body-list-checkbox-todo-end ""
     :body-list-checkbox-done     "[X] "
     :body-list-checkbox-done-end ""
     :body-line-format            "%s"
     :body-line-wrap               79
     :body-text-prefix            ""
     :body-text-suffix            ""
     ))
#+END_SRC

** Presentations

   Currently generating presentations from my org-mode files using
   [[https://github.com/hakimel/reveal.js/][reveal.js]] and [[https://github.com/yjwen/org-reveal][org-reveal]].

#+BEGIN_SRC elisp
  (require 'ox-reveal)
  
  (setq org-reveal-root (concat "file://" (getenv "HOME") "/Other/reveal.js"))
  
  (setq org-reveal-postamble "Howard Abrams")
#+END_SRC

** MobileOrg

   I use [[http://mobileorg.ncogni.to/doc/getting-started/using-dropbox/][Dropbox with MobileOrg]] in order to read my notes on my iPad.

   The "global" location of my Org files on my local system:

#+BEGIN_SRC elisp
  (setq org-directory "~/Dropbox/org/personal")
#+END_SRC

   Set the name of the file where new notes will be stored

#+BEGIN_SRC elisp
  (setq org-mobile-inbox-for-pull "~/Dropbox/org/flagged.org")
#+END_SRC

   Set to <your Dropbox root directory>/MobileOrg.

#+BEGIN_SRC elisp
  (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
#+END_SRC

   To get this going, we just need to: =M-x org-mobile-push=

** The Tower of Babel

   The trick to literate programming is in the [[http://orgmode.org/worg/org-contrib/babel/intro.html][Babel project]], which
   allows org-mode to not only interpret source code blocks, but
   evaluate them and tangle them out to a file.

#+BEGIN_SRC elisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((sh         . t)
   (js         . t)
   (coffee     . t)
   (emacs-lisp . t)
   (perl       . t)
   (scala      . t)
   (clojure    . t)
   (python     . t)
   (dot        . t)
   (css        . t)
   (plantuml   . t)))
#+END_SRC

   It seems to automatically recognize the language used in a source
   block, but if not, call =org-babel-lob-ingest= to add all the
   languages from the code block into the list that Babel supports.
   Keystroke: =C-c C-v i=.

*** Just Evaluate It

    I'm normally fine with having my code automatically evaluated.

#+BEGIN_SRC elisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

*** Font Coloring in Code Blocks
    
    Normally, fontifying the individual code blocks makes it
    impossible to work with, so instead of turning it on at the global
    level for all blocks, I created a couple of keystrokes to
    selectively colorize one block at a time.

#+BEGIN_SRC elisp
  ; (setq org-src-fontify-natively t)
  
  (global-set-key (kbd "<f9> g") 'org-src-fontify-buffer)
  (global-set-key (kbd "<f9> f") 'org-src-fontify-block)
#+END_SRC
* Programming Languages
** Clojure

   Me like [[http://clojure.org][Clojure]], and since it is a LISP, then [[https://github.com/clojure-emacs][Emacs likes it]] too.
   Here are all the packages related to Clojure that I use. Note
   my migration from [[https://github.com/clojure-emacs/nrepl.el][nrepl]] to [[https://github.com/clojure-emacs/cider][Cider]].

#+BEGIN_SRC elisp
  (packages-install '( ac-nrepl
                       clojure-mode
                       clojure-cheatsheet
                       clojure-snippets
                       clojurescript-mode
                       cider
                       elein
                       ;; nrepl
                       ;; nrepl-ritz
                       paredit
                       rainbow-delimiters  ;; Mode for alternating paren colors
                       ))
#+END_SRC

   Need to add Yasnippets to Clojure mode:

#+BEGIN_SRC elisp
  (require 'clojure-mode)
  
  (add-hook 'clojure-mode-hook
            '(lambda ()
               (yas/minor-mode-on)))
#+END_SRC

   According to the [[https://github.com/weavejester/compojure/wiki][Compojure Wiki]], the following code makes their
   macros look prettier:

#+BEGIN_SRC elisp
  (define-clojure-indent
    (defroutes 'defun)
    (GET 2)
    (POST 2)
    (PUT 2)
    (DELETE 2)
    (HEAD 2)
    (ANY 2)
    (context 2))
#+END_SRC

   Most LISP-based programming is better with rainbow ponies:

#+BEGIN_SRC elisp
  (add-hook 'prog-mode-hook  'rainbow-delimiters-mode)
  (add-hook 'cider-repl-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

   With the =elein= project installed, it allows us to do things
   like: =M-x elein-run-cmd koan run=

   Really want to try out my new [[file:~/Dropbox/Clojure/clojuredocs-emacs/org/clojuredocs.org][ClojureDocs functions]]. Note: You
   need to do the following steps:

#+BEGIN_SRC sh :tangle no
  cd ~/Other/... # or whatever
  git clone https://github.com/howardabrams/clojuredocs-emacs.git
  cd ~/.emacs.d
  ln -s ~/Other/clojuredocs-emacs/clojuredocs.el .
#+END_SRC

   Then the following code will work:

#+BEGIN_SRC emacs-lisp
  (if (file-exists-p "~/.emacs.d/clojuredocs.el")
      (load-library "clojuredocs"))
#+END_SRC

   Finally, if you are just learning Clojure, check out [[http://www.4clojure.com/][4Clojure]] and then
   install [[https://github.com/joshuarh/4clojure.el][4clojure-mode]].

*** Paredit

    One of the cooler features of Emacs is the [[http://emacswiki.org/emacs/ParEdit][ParEdit mode]] which
    keeps all parenthesis balanced in Lisp-oriented languages.
    See this [[http://www.emacswiki.org/emacs/PareditCheatsheet][cheatsheet]].

#+BEGIN_SRC elisp
  (autoload 'paredit-mode "paredit"
    "Minor mode for pseudo-structurally editing Lisp code." t)
#+END_SRC

    To associate specific language modes with ParEdit, first create a
    helper function:

#+BEGIN_SRC elisp
  (defun turn-on-paredit () (paredit-mode 1))
#+END_SRC

    Then associate the following Lisp-based modes with ParEdit:

#+BEGIN_SRC elisp
  (add-hook 'emacs-lisp-mode-hook       'turn-on-paredit)
  (add-hook 'lisp-mode-hook             'turn-on-paredit)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-paredit)
  (add-hook 'scheme-mode-hook           'turn-on-paredit)
  (add-hook 'clojure-mode-hook          'turn-on-paredit)
  (add-hook 'cider-repl-mode-hook       'turn-on-paredit)
  (add-hook 'sibiliant-mode-hook        'turn-on-paredit)
#+END_SRC

    Note, without the helpful =turn-on-paredit= function defined
    above, I'd have to do something like:

#+BEGIN_SRC elisp :tangle no
  (add-hook 'clojure-mode-hook          (lambda () (paredit-mode +1)))
#+END_SRC

*** ElDoc

    Need to get [[http://emacswiki.org/emacs/ElDoc][ElDoc]] working with Clojure (oh, and with Emacs Lisp).
    Do I need [[https://gist.github.com/tomykaira/1386472][this EL file]]?

#+BEGIN_SRC elisp
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'clojure-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
#+END_SRC

*** Cider

  The [[https://github.com/clojure-emacs/cider][Cider project]] is da bomb. Usage:

   - =cider-jack-in= - For starting an nREPL server and setting
     everything up. Keyboard: =C-c M-j=
   - =cider= to connect to an existing nREPL server.

  Don't care much for the extra buffers that show up when you start:

#+BEGIN_SRC elisp
  (setq nrepl-hide-special-buffers t)
#+END_SRC

Stop the error buffer from popping up while working in buffers other than the REPL:

#+BEGIN_SRC elisp
  (setq cider-popup-stacktraces nil)
#+END_SRC

*** TODO Pull Clojure section into a separate file

    This section is completely self-contained, i.e. doesn't depend on
    other parts in this file, so I can pull this into a separate file
    and load it up like:

#+BEGIN_SRC elisp :tangle no
(eval-after-load 'clojure-mode '(require 'my-clojure-setup))
#+END_SRC

** Scala

   We need to load the [[https://github.com/haxney/scala-mode][scala mode]].
   We follow [[http://www.scala-lang.org/node/354][these instructions]] to hook it up with [[http://code.google.com/p/yasnippet/][Yasnippet]].

#+BEGIN_SRC elisp
  (autoload 'scala-mode "scala-mode"
    "Programming mode for Scala." t nil)

  ;; Shouldn't this be done by default?
  (add-to-list 'auto-mode-alist '("\\.scala$" . scala-mode))
  
  (add-hook 'scala-mode-hook
            '(lambda ()
               (yas/minor-mode-on)
               (scala-mode-feature-electric-mode)))
#+END_SRC

   We follow [[http://jawher.net/2011/01/17/scala-development-environment-emacs-sbt-ensime/][these instructions]] to set it up with [[https://github.com/aemoncannon/ensime][Ensime]], since
   it current is not available as a package.

#+BEGIN_SRC elisp
  (if (file-exists-p "~/.emacs.d/ensime")
      (progn
        (add-to-list 'load-path "~/.emacs.d/ensime/elisp")
        (autoload 'ensime-mode "ensime-mode"
          "Programming support mode for Scala." t nil)
        (add-hook 'scala-mode-hook 'ensime-scala-mode-hook)))
#+END_SRC

** JavaScript

   JavaScript should have three parts:
   - Syntax highlight (already included)
   - Syntax verification (with flycheck)
   - Interactive REPL

   We use the following packages based on =js2-mode=:

#+BEGIN_SRC elisp
  (packages-install '( js-comint
                       js2-mode
                       ac-js2
                       js2-refactor
                       json-mode
                       coffee-mode ))
#+END_SRC

   Why yes, it seems that the JavaScript mode has a special
   indentation setting. Go below?

#+BEGIN_SRC elisp
  (setq js-basic-indent 2)
  (setq-default js2-basic-indent 2)

  (setq-default js2-basic-offset 2)
  (setq-default js2-auto-indent-p t)
  (setq-default js2-cleanup-whitespace t)
  (setq-default js2-enter-indents-newline t)
  (setq-default js2-global-externs "jQuery $")
  (setq-default js2-indent-on-enter-key t)
  (setq-default js2-mode-indent-ignore-first-tab t)

  (setq-default js2-global-externs '("module" "require" "buster" "sinon" "assert" "refute" "setTimeout" "clearTimeout" "setInterval" "clearInterval" "location" "__dirname" "console" "JSON"))

  ;; We'll let fly do the error parsing...
  (setq-default js2-show-parse-errors nil)

  (autoload 'js2-mode "js2-mode" nil t)
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+END_SRC

   Change the word "function" to just an "f":

#+BEGIN_SRC elisp
  (font-lock-add-keywords
   'js2-mode `(("\\(function *\\)("
               (0 (progn (compose-region (match-beginning 1) (match-end 1) "ƒ")
                         nil)))))
#+END_SRC

   Place warning font around TODO and others:

#+BEGIN_SRC elisp
  (font-lock-add-keywords 'js2-mode
                          '(("\\<\\(FIX\\|TODO\\|FIXME\\|HACK\\|REFACTOR\\):"
                             1 font-lock-warning-face t)))
#+END_SRC

*** FlyMake and JSHint

   While editing JavaScript is baked into Emacs, it is kinda cool to
   have it give you red sections based on [[http://www.jshint.com/][jshint]].
   This is now done with Flycheck, and we now don't use [[http://www.emacswiki.org/emacs/FlymakeJavaScript][FlyMake]].

#+BEGIN_SRC elisp :tangle no
  (autoload 'flymake-jshint "flymake-jshint"
    "Error and linting support mode for JavaScript." t nil)

  (add-hook 'js-mode-hook
            (lambda () (flymake-mode 1)))
#+END_SRC

   Now load and edit a JavaScript file, like [[file:~/jshint-code-test.js][jshint-code-test.js]].

*** Refactoring JavaScript

    The [[https://github.com/magnars/js2-refactor.el][js2-refactor]] mode should start with `C-c C-m` and then a two-letter mnemonic shortcut.

       * =ef= is =extract-function=: Extracts the marked expressions out into a new named function.
       * =em= is =extract-method=: Extracts the marked expressions out into a new named method in an object literal.
       * =ip= is =introduce-parameter=: Changes the marked expression to a parameter in a local function.
       * =lp= is =localize-parameter=: Changes a parameter to a local var in a local function.
       * =eo= is =expand-object=: Converts a one line object literal to multiline.
       * =co= is =contract-object=: Converts a multiline object literal to one line.
       * =eu= is =expand-function=: Converts a one line function to multiline (expecting semicolons as statement delimiters).
       * =cu= is =contract-function=: Converts a multiline function to one line (expecting semicolons as statement delimiters).
       * =ea= is =expand-array=: Converts a one line array to multiline.
       * =ca= is =contract-array=: Converts a multiline array to one line.
       * =wi= is =wrap-buffer-in-iife=: Wraps the entire buffer in an immediately invoked function expression
       * =ig= is =inject-global-in-iife=: Creates a shortcut for a marked global by injecting it in the wrapping immediately invoked function expression
       * =ag= is =add-to-globals-annotation=: Creates a =/*global */= annotation if it is missing, and adds the var at point to it.
       * =ev= is =extract-var=: Takes a marked expression and replaces it with a var.
       * =iv= is =inline-var=: Replaces all instances of a variable with its initial value.
       * =rv= is =rename-var=: Renames the variable on point and all occurrences in its lexical scope.
       * =vt= is =var-to-this=: Changes local =var a= to be =this.a= instead.
       * =ao= is =arguments-to-object=: Replaces arguments to a function call with an object literal of named arguments. Requires yasnippets.
       * =3i= is =ternary-to-if=: Converts ternary operator to if-statement.
       * =sv= is =split-var-declaration=: Splits a =var= with multiple vars declared, into several =var= statements.
       * =uw= is =unwrap=: Replaces the parent statement with the selected region.
      
#+BEGIN_SRC elisp
  (if (autofeaturep 'js2-refactor)
      (progn
        (require 'js2-refactor)
        (js2r-add-keybindings-with-prefix "C-c C-m")))
#+END_SRC

*** JavaScript REPL

    We can use two different approaches for a JavaScript REPL.
    *Note:* Neither are working very effectively.

**** Client JS with MozRepl

     Assuming you have Mozilla Firefox running with the [[https://addons.mozilla.org/en-US/firefox/addon/mozrepl/][MozRepl]]
     add-on and you've installed a =moz= executable:

#+BEGIN_SRC elisp :tangle no
  (autoload 'moz-minor-mode "moz" "Mozilla Minor and Inferior Mozilla Modes" t)
  
  (add-hook 'js-mode-hook 'javascript-custom-setup)
  (defun javascript-custom-setup ()
    (moz-minor-mode 1))
#+END_SRC

     This gives you the following commands:

     - C-c C-s: open a MozRepl interaction buffer and switch to it
     - C-c C-l: save the current buffer and load it in MozRepl
     - C-M-x: send the current function (as recognized by c-mark-function) to MozRepl
     - C-c C-c: send the current function to MozRepl and switch to the interaction buffer
     - C-c C-r: send the current region to MozRepl

**** Server JS with Node.js

     Use [[http://js-comint-el.sourceforge.net][js-comint]], but hook it up with node.js:

#+BEGIN_SRC elisp
  (autoload 'js-comint "js-comint"
    "Hooking JavaScript interpreter up to the JS Files." t nil)
  
  (setenv "NODE_NO_READLINE" "1")   ;; Turn off fancy node prompt
  ;; Use node as our repl
  (setq inferior-js-program-command "node")
#+END_SRC

    According to [[http://nodejs.org/api/all.html#all_repl][these instructions]], we set the =NODE_NO_READLINE=
    variable.

    Need some prompt configuration for the REPL:

#+BEGIN_SRC elisp
  (setq inferior-js-mode-hook
        (lambda ()
          ;; We like nice colors
          (ansi-color-for-comint-mode-on)
          ;; Deal with some prompt nonsense
          (add-to-list
           'comint-preoutput-filter-functions
           (lambda (output)
             (replace-regexp-in-string "\033\\[[0-9]+[GK]" "" output)
             (replace-regexp-in-string ".*1G.*3G" "&GT;" output)
             (replace-regexp-in-string "&GT;" "> " output)))))
#+END_SRC

    Start the JavaScript node REPL with: =run-js=
    Set up some helpful keyboard instructions:

#+BEGIN_SRC elisp
  (add-hook 'js2-mode-hook
          (lambda () 
            (local-set-key (kbd "C-c C-c") #'js-send-buffer)
            (local-set-key (kbd "C-c C-r") #'js-send-region)
            (local-set-key (kbd "C-c C-s") #'js-send-last-sexp)
            (local-set-key (kbd "C-c C-z") #'run-js)))
#+END_SRC

    Wanna try it all out?

#+BEGIN_SRC js :tangle no
  function factorial(n) { 
    return n == 0 ? 1 : n * factorial(n - 1);
  }
  return factorial(16);
#+END_SRC

**** Slime-JS

     Slime seems a lot better for REPL work than js-comint.

#+BEGIN_SRC elisp
(add-hook 'after-init-hook
  #'(lambda ()
    (when (locate-library "slime-js")
      (require 'setup-slime-js))))
#+END_SRC

*** Coffee
 
    Gotta load up CoffeeScript files, but I use a special shell
    script that loads up my special 'coughy' environment
 
 #+BEGIN_SRC elisp
  (setq coffee-command (concat (getenv "HOME") "/bin/coughy"))
 #+END_SRC

** Java

   Eh ... why use Java anymore?

** Python

   Stole Python package ideas from [[https://github.com/gabrielelanaro/emacs-for-python][Gabriel Elanaro's git project]].  The
   question is whether I use Rope or Jedi for auto-completion.  Seems
   like Rope is better, so I will use it instead of Jedi... for now.

#+BEGIN_SRC elisp
  (packages-install '( nose
                       jedi
                       ein
                       virtualenv ))
#+END_SRC

   Make sure that PATH can reference the Python executables, and
   since I am installing a updated Python...

#+BEGIN_SRC elisp :tangle no
  (setenv "PATH" (concat "/usr/local/bin:" (getenv "PATH")))
#+END_SRC

   WSGI files are just Python files in disguise, so tell them to use
   the Python environment:

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '("\\.wsgi$" . python-mode))
#+END_SRC

*** Debugging

    Use the [[https://pypi.python.org/pypi/virtualenv][virtualenv]] world of goodness, but only if it is installed.
    This allows me to =M-x virtualenv-workon= and specify the virtual
    environment to run all the Python gunk from within Emacs.

#+BEGIN_SRC elisp
  (if (autofeaturep 'virtualenv)
      (progn
          (require 'virtualenv)))
#+END_SRC

*** Jedi

    Auto-completion system for Python. This code hooks Jedi into the
    standard Python mode. See [[http://tkf.github.io/emacs-jedi/][these instructions]] for details. New
    keys:

    - =C-Tab= for auto complete.
    - =C-.= to jump to definition.
    - =C-c d= to show the function documentation

#+BEGIN_SRC elisp :tangle no
  (if (autofeaturep 'jedi-mode)
      (progn
        (add-hook 'python-mode-hook 'jedi:setup)
        (add-hook 'python-mode-hook 'jedi:ac-setup)
        (setq jedi:setup-keys t)                      ; optional
        (setq jedi:complete--dot t)))                 ; optional
#+END_SRC

*** Flymake for Python

    Lint-style syntax checking for Python builds on the regular
    Flymake package, however, I am now using Flycheck for that.

#+BEGIN_SRC elisp :tangle no
  (if (autofeaturep 'flymake-python-pyflakes)
      (progn
        (require 'flymake-python-pyflakes)
        (add-hook 'python-mode-hook 'flymake-python-pyflakes-load)))
#+END_SRC

*** Nose

    Unit test and code coverage tool for Python now comes to Emacs
    with [[http://ivory.idyll.org/articles/nose-intro.html][Python Nose]].

#+BEGIN_SRC elisp
  (if (autofeaturep 'nose)
        (progn
         (require 'nose)
  
         ;;   Include this line only for people with non-eco non-global test
         ;;   runners... like the Python Koans:
         (add-to-list 'nose-project-names
                      "~/Google\ Drive/python_koans/python2")))
#+END_SRC

*** IPython

   Got iPython and EIN? Great! Remember, pre-install the following packages:
   - websocket
   - request
   - ein

#+BEGIN_SRC elisp
  (if (autofeaturep 'ein)
        (progn 
          (require 'ein)
          (setq ein:use-auto-complete t)))
#+END_SRC

   After starting the IPython notebook server,
   type =M-x ein:notebooklist-open= to open notebook list.

*** Rope

    After installing the following Python libraries using =pip= (in a
    global environment):

    - [[http://rope.sourceforge.net/index.html][Rope]]
    - [[http://rope.sourceforge.net/ropemacs.html][Ropemacs]]
    - [[https://pypi.python.org/pypi/ropemode][Ropemode]]

    And have installed [[http://pymacs.progiciels-bpi.ca/pymacs.html][pymacs]], with both =package-install= as well as
    by cloning [[https://github.com/pinard/Pymacs.git][this Git repo]] and issuing a =make install=.
    According to [[http://stackoverflow.com/questions/2855378/ropemacs-usage-tutorial][this discusssion]], we /just/ need to:

#+BEGIN_SRC elisp
  ;; (require 'pymacs)
    
  (autoload 'pymacs-apply "pymacs")
  (autoload 'pymacs-call "pymacs")
  (autoload 'pymacs-eval "pymacs" nil t)
  (autoload 'pymacs-exec "pymacs" nil t)
  (autoload 'pymacs-load "pymacs" nil t)
  (autoload 'pymacs-autoload "pymacs")
  
  ;;(eval-after-load "pymacs"
  ;;  '(add-to-list 'pymacs-load-path YOUR-PYMACS-DIRECTORY"))
  
  (add-hook 'python-mode-hook
            (lambda ()
              (pymacs-load "ropemacs" "rope-")
              (setq ropemacs-enable-autoimport t)))
  
  (defun rope-before-save-actions () 
    ;; Does nothing but save us from an error.
    )
  (defun rope-after-save-actions () 
    ;; Does nothing but save us from an error.
    )
  (defun rope-exiting-actions () 
    ;; Does nothing but save us from an error.
    )
#+END_SRC

    A helluva lot of work, but it is worth it. As long as the Rope
    instance stays alive and doesn't die. Then it becomes pretty
    annoying.

** HTML, CSS and Web Work
   
   The basic web features of Emacs are often good enough, but
   [[https://github.com/smihica/emmet-mode][Emmet-Mode]] looks pretty sweet.

#+BEGIN_SRC elisp
  (packages-install '( emmet-mode
                       web-mode
                       mustache-mode
                       handlebars-mode
                       htmlize ))    ;; I use this more for org-mode
#+END_SRC

   Now, hook emmet up to SGML and all the other modes:

#+BEGIN_SRC elisp
  (add-hook 'sgml-mode-hook 'emmet-mode) ;; Auto-start on any markup modes
  (add-hook 'css-mode-hook  'emmet-mode) ;; enable Emmet's css abbreviation.  
#+END_SRC

   Set emmet to only use 2 spaces:

#+BEGIN_SRC elisp
  (add-hook 'emmet-mode-hook (lambda () 
                               (setq emmet-indentation 2))) ;; indent 2 spaces.
#+END_SRC

   If you want the cursor to be positioned between first empty quotes
   after expanding:

#+BEGIN_SRC elisp :tangle no
  (setq emmet-move-cursor-between-quotes t) ;; default nil
#+END_SRC

* Tools
** Git

   Git is [[http://emacswiki.org/emacs/Git][already part of Emacs]]. However, [[http://philjackson.github.com/magit/magit.html][Magit]] is sweet.
   
#+BEGIN_SRC elisp
  (autoload 'magint "magit"
    "Hooking Git up to supported files." t nil)

  (global-set-key (kbd "M-C-g") 'magit-status)
#+END_SRC

   I install and use the [[https://github.com/syohex/emacs-git-gutter-fringe][Git Gutter Fringe]] as it works better with
   windowing versions of Emacs.

#+BEGIN_SRC elisp
  (if (autofeaturep 'git-gutter-fringe)
      (progn
        (when (window-system)
          (require 'git-gutter-fringe)
          (global-git-gutter-mode +1)
          (setq-default indicate-buffer-boundaries 'left)
          (setq-default indicate-empty-lines +1))))
#+END_SRC

** Markdown

   Don't use Markdown nearly as much as I used to, but I'm surprised
   that the following extension-associations aren't the default:

#+BEGIN_SRC elisp
  (autoload 'markdown-mode "markdown-mode.el"
     "Major mode for editing Markdown files" t)
  (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.txt\\'" . markdown-mode))
#+END_SRC   

   Using the =org-text-wrapper= function, I create some wrapper
   functions to make it easier to bold text in Markdown files:

#+BEGIN_SRC elisp
  (defun markdown-bold () "Wraps the region with double asterisks."
    (interactive)
    (org-text-wrapper "**"))
  (defun markdown-italics () "Wraps the region with asterisks."
    (interactive)
    (org-text-wrapper "*"))
  (defun markdown-code () "Wraps the region with equal signs."
    (interactive)
    (org-text-wrapper "`"))
#+END_SRC

   Now I can associate some keystrokes to =markdown-mode=:

#+BEGIN_SRC elisp
  (add-hook 'markdown-mode-hook
        (lambda ()
          (local-set-key (kbd "A-b") 'markdown-bold)
          (local-set-key (kbd "A-i") 'markdown-italics)
          (local-set-key (kbd "A-=") 'markdown-code)))
#+END_SRC

** Wiki

   Now that Atlassian changed this Wiki system so that [[https://code.google.com/p/confluence-el/][confluence.el]]
   doesn't work anymore (yeah, not an improvement, Atlassian), I can
   still use the =confluence-edit-mode= for anything with a =.wiki=
   extension.

#+BEGIN_SRC elisp
  (autoload 'confluence-edit-mode "confluence-edit-mode.el"
     "Major mode for editing Wiki documents" t)
  (add-to-list 'auto-mode-alist '("\\.wiki\\'" . confluence-edit-mode))
#+END_SRC

   I would also like to create and use some formatting wrappers.

#+BEGIN_SRC elisp
  (defun wiki-bold () "Wraps the region with single asterisks."
    (interactive)
    (org-text-wrapper "*"))
  (defun wiki-italics () "Wraps the region with underbars."
    (interactive)
    (org-text-wrapper "_"))
  (defun wiki-code () "Wraps the region with curly brackets."
    (interactive)
    (org-text-wrapper "{{" "}}"))
#+END_SRC

   Now I can associate some keystrokes to =markdown-mode=:

#+BEGIN_SRC elisp
  (add-hook 'confluence-edit-mode-hook
        (lambda ()
          (local-set-key (kbd "A-b") 'wiki-bold)
          (local-set-key (kbd "A-i") 'wiki-italics)
          (local-set-key (kbd "A-=") 'wiki-code)))
#+END_SRC

** PlantUML

   To get [[http://plantuml.sourceforge.net/download.html][PlantUML]] working in Emacs, first, get the "mode" working for
   editing the files:

#+BEGIN_SRC elisp
  (setq plantuml-jar-path (concat (getenv "HOME") "/bin/plantuml.jar"))
#+END_SRC

   Second, to get [[http://zhangweize.wordpress.com/2010/08/25/creating-uml-images-by-using-plantuml-and-org-babel-in-emacs/][PlantUML]] working in org-mode, set a different variable:

#+BEGIN_SRC elisp
  (setq org-plantuml-jar-path (concat (getenv "HOME") "/bin/plantuml.jar"))
#+END_SRC

* Applications
** Eshell

   Great shell with some good tweaks taken from [[https://github.com/eschulte/emacs24-starter-kit/blob/master/starter-kit-eshell.org][the Starter Kit]]
   project. Ignoring the =.git= directories seem like a good idea.

#+BEGIN_SRC elisp
  (setq eshell-cmpl-cycle-completions nil
        eshell-save-history-on-exit t
        eshell-cmpl-dir-ignore "\\`\\(\\.\\.?\\|CVS\\|\\.svn\\|\\.git\\)/\\'")
#+END_SRC

   Eshell would get somewhat confused if I ran the following commands
   directly through the normal Elisp library, as these need the better
   handling of ansiterm:

#+BEGIN_SRC elisp
  (add-hook 'eshell-mode-hook
     '(lambda nil
        (add-to-list 'eshell-visual-commands "ssh")
        (add-to-list 'eshell-visual-commands "tail")))
#+END_SRC

   Need the correct PATH even if we start Emacs from the GUI:

#+BEGIN_SRC elisp
  (setenv "PATH"
          (concat
           "/usr/local/bin:/usr/local/sbin:"
           (getenv "PATH")))
#+END_SRC

   If any program wants to pause the output through the =$PAGER=
   variable, well, we don't really need that:

#+BEGIN_SRC elisp
  (setenv "PAGER" "cat")
#+END_SRC

   Gotta have some [[http://www.emacswiki.org/emacs/EshellAlias][shell aliases]], right?

#+BEGIN_SRC elisp
  (defalias 'e 'find-file)
  (defalias 'emacs 'find-file)
#+END_SRC

   Replacing the window with the new buffer may not be what I want.
 
#+BEGIN_SRC elisp
  (defalias 'ee 'find-file-other-window)
#+END_SRC

   Some of my favorite bash aliases, can be even more helpful in
   Eshell.

   However, my =gst= command should be an alias to =magit-status=, but
   using the =alias= doesn't pull in the current working directory, so
   I make it a function, instead:

#+BEGIN_SRC elisp
  (defun eshell/gst (&rest args)
      (magit-status (pop args) nil))

  (defun eshell/l (&rest args)
      (dired (pop args) nil))
#+END_SRC

** Twitter

   I know, I know, reading my [[http://www.emacswiki.org/emacs-en/TwitteringMode][twitter feed in Emacs]] is pretty geeking
   awesome. And I can filter out tweets that match a pattern that annoys me:

#+BEGIN_SRC elisp
  (setq twittering-tweet-filters '("kickstart" "#burritowatch"))

  (defun twittering-filter-tweets ()
    (setq non-matching-statuses '())
    (dolist (status twittering-new-tweets-statuses)
      (setq matched-tweets 0)
      (dolist (pat twittering-tweet-filters)
        (if (string-match pat (cdr (assoc 'text status)))
            (setq matched-tweets (+ 1 matched-tweets))))
      (if (= 0 matched-tweets)
          (setq non-matching-statuses (append non-matching-statuses `(,status)))))
    (setq new-statuses non-matching-statuses))

  (add-hook 'twittering-new-tweets-hook 'twittering-filter-tweets)
#+END_SRC

   Need to enable spell-checking for the Twitter mode.

#+BEGIN_SRC elisp
(add-hook 'twittering-edit-mode-hook (lambda () (ispell-minor-mode) (flyspell-mode)))
#+END_SRC

** Circe

   I find reading Twitter and IRC in Emacs a good idea. Really. Small
   bits of the Emacs window are accessible and whatnot. Currently,
   however, [[https://github.com/jorgenschaefer/circe/wiki][Circe]] isn't available in the standard locations, so I have
   it downloaded and installed, and need the following configuration:

#+BEGIN_SRC elisp
  (require 'circe)

  (setq circe-network-options
        `(("Ciphermonkeys"
           :host "irc.ciphermonkeys.org"
           :nick "ha"
           :channels ("#1101"))))
#+END_SRC

   Perhaps we want to join other channels ... you know, just for
   fun to see if there is something else to waste time.

#+BEGIN_SRC elisp
  (defun irc ()
    "Connect to all my IRC servers... well, just this one."
    (interactive)
    (circe "Ciphermonkeys"))
#+END_SRC

   Let's hide all the JOIN, PART and other messages that I don't care
   about:

#+BEGIN_SRC elisp
  (circe-set-display-handler "JOIN" (lambda (&rest ignored) nil))
  (circe-set-display-handler "PART" (lambda (&rest ignored) nil))
  (circe-set-display-handler "QUIT" (lambda (&rest ignored) nil))
#+END_SRC

   Circe (actually, lui) has the ability to intercept long pastes if
   it is done in a single input. Lui will then ask if the user would
   prefer to use a paste service.

#+BEGIN_SRC elisp
  (require 'lui-autopaste)
  (add-hook 'circe-channel-mode-hook 'enable-lui-autopaste)
#+END_SRC

#+BEGIN_SRC elisp
  (setq lui-flyspell-p t
        lui-flyspell-alist '((".*" "american")))
#+END_SRC

* Technical Artifacts

  Before you can build this on a new system, make sure that you put
  the cursor over any of these properties, and hit: =C-c C-c=

#+DESCRIPTION: A literate programming version of my Emacs Initialization script, loaded by the .emacs file.
#+PROPERTY:    results silent
#+PROPERTY:    tangle ~/.emacs-ext.el
#+PROPERTY:    eval no-export
#+PROPERTY:    comments org
#+OPTIONS:     num:nil toc:nil todo:nil tasks:nil tags:nil
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
