#+TITLE:  Emacs Configuration File
#+AUTHOR: Howard Abrams
#+EMAIL:  howard.abrams@gmail.com

* Introduction

  This is my =.emacs= file, written using [[http://www.orgmode.org][org-mode]], so that I can
  organize it and take notes on all the complexity.

#+BEGIN_HTML
  <p>
    You can download the <a href="dot-emacs.org">original org-mode
    file</a> or view the <a href="dot-emacs.el">tangled end results</a>.
  </p>
#+END_HTML

  If you are playing around with the =org-mode= version, note:

  - The =tab= key opens/close a particular section
  - Shift + =tab= cycles between the outline and full text
  - Render it with:  =C-c C-v t=
  - Creates a file:  =~/.emacs-ext.el=

** Emacs Executable

   This file is really a /script/ that requires version 24 of Emacs.
   While I often use [[http://emacsformacosx.com/builds][Emacs for Mac]], lately, I've been building from
   [[http://brew.sh/][Homebrew]] with the following:

#+BEGIN_SRC sh :tangle no
brew install emacs --HEAD --cocoa --srgb
brew linkapps
#+END_SRC

   Not only does this install the latest version of Emacs in
   =/usr/local/bin/emacs=, but it also links a GUI version in
   =/Application/Emacs.app=. Goody.

** Loading this File

   To "load" the contents of this file, add the following to =$HOME/.emacs=:

#+BEGIN_EXAMPLE
  ;; Load our Literate Programming version of our Dot Emacs
  ;; file, from file: ~/Work/dot-files/emacs.org
  (unless (boundp 'aquamacs-version)
    (load-file "~/.emacs-ext.el"))
#+END_EXAMPLE

   *Note:* I only load this from a "normal" Emacs distribution, which allows
   me to play around with [[http://aquamacs.org/][Aquamacs]] and [[http://eschulte.github.io/emacs-starter-kit/][Starter Kits]] for recommendation
   to people new to Emacs.

** Editing Warning

  Begin this initialization script with a warning not to edit the
  generated file:

#+NAME: Note
#+BEGIN_SRC elisp :comments off
  ;;; ------------------------------------------
  ;;; Do not edit the generated file, as it has
  ;;; been generated, as a tangled file, by the
  ;;; fandifluous org-mode.
  ;;;
  ;;; Source: ~/Work/dot-files/emacs.org
  ;;; ------------------------------------------
#+END_SRC

* General Settings

** Directory Structure

   In case this is the first time running this on a computer, we need
   to make sure the following directories have been created.

#+BEGIN_SRC elisp
  (let* ((subdirs '("elisp" "backups" "snippets" "ac-dict"))
         (fulldirs (mapcar (lambda (d) (concat user-emacs-directory d)) subdirs)))
    (dolist (dir fulldirs)
      (when (not (file-exists-p dir))
        (message "Make directory: %s" dir)
        (make-directory dir))))
#+END_SRC

** Setting up the Load Path

   Extra packages not available via the package manager go in my
   personal stash at: =$HOME/.emacs.d/elisp=

#+BEGIN_SRC elisp
  (add-to-list 'load-path (concat user-emacs-directory "elisp"))
#+END_SRC

   Make sure that =PATH= variable for finding binary files can
   is the same as what Emacs will look for binary files...but only if
   we are running from the =Applications= directory.

#+BEGIN_SRC elisp
  (when window-system
    (let ((path-from-shell (shell-command-to-string "bash -i -c 'echo $PATH'")))
      (setenv "PATH" path-from-shell)
      (setq exec-path (split-string path-from-shell path-separator))))
#+END_SRC

** Customization Section

   While I would rather program my configurations, sometimes the Emacs
   menu system is "good enough", but I want it in its own file:

#+BEGIN_SRC elisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file))
#+END_SRC

** Package Manager

   Emacs has become like every other operating system, and now has a
   [[http://tromey.com/elpa/][package manager]] with its own collection repository, but since it is
   so conservative, we need to add more repositories to get all the
   sweet goodness, I demand.

#+BEGIN_SRC elisp
  (require 'package)

  (setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                           ("gnu"       . "http://elpa.gnu.org/packages/")
                           ("melpa"     . "http://melpa.milkbox.net/packages/")
                           ("marmalade" . "http://marmalade-repo.org/packages/")))
#+END_SRC

   While we can now do a =package-list-packages=, you can install and
   everything is good, however, we can't =require= any of these
   packages (in order to customize them in this file) until we do
   this:

#+BEGIN_SRC elisp
  (package-initialize)
#+END_SRC

** Installing Extra Packages

   Not sure why the package management system doesn't come with a
   programmatic way to specify what packages should be installed. Oh
   yeah, this is pretty new. Looks like everyone just rolls there own,
   so this is mine.

#+BEGIN_SRC elisp
  (defun filter (condp lst)
    "Emacs Lisp doesn’t come with a ‘filter’ function to keep elements that satisfy
  a conditional and excise the elements that do not satisfy it. One can use ‘mapcar’
  to iterate over a list with a conditional, and then use ‘delq’ to remove the ‘nil’
  values."
    (delq nil
          (mapcar (lambda (x) (and (funcall condp x) x)) lst)))

  (defun inverse-filter (condp lst)
    "A filter function, but returns a list of the entries that don't match the predicate."
    (delq nil
          (mapcar (lambda (x) (and (not (funcall condp x)) x)) lst)))

  (defun packages-install (packages)
    "Given a list of packages, this will install them from the standard locations."
    (let ((to-install (inverse-filter 'package-installed-p packages)))
      (when to-install
        (package-refresh-contents)
        (dolist (it to-install)
            (package-install it)
        (delete-other-windows)))))
#+END_SRC


   This means that at any point in my configuration file, I can
   specify a list of packages to make sure they are installed.

#+BEGIN_SRC elisp
  (packages-install
                 '(auto-complete
                   circe
                   dired-details
                   color-identifiers-mode  ;; Color variables differently
                   epl
                   esh-buf-stack
                   expand-region
                   flycheck
                   flycheck-color-mode-line
                   flyspell
                   git-commit-mode
                   git-gutter-fringe
                   gitconfig-mode
                   gitignore-mode
                   graphviz-dot-mode
                   iy-go-to-char
                   key-chord
                   magit
                   markdown-mode
                   multiple-cursors
                   nlinum
                   ;; redo+             ;; If not installed, edit mac-key-mode
                   smex
                   thesaurus
                   undo-tree
                   visual-regexp
                   yasnippet))
#+END_SRC

** Package Verification

   The =(require)= is a problem if the library isn't available, and if
   it isn't available, then this file dies and doesn't complete.
   Seems like it would be nice to wrap the configuration of a package
   in a block that is ignored if the package isn't available.

   The following code was found [[http://stackoverflow.com/questions/7790382/how-to-determine-whether-a-package-is-installed-in-elisp][in this discussion]], but I believe
   I'll be phasing this out now that I can simply install a long list
   of packages when I start.

#+BEGIN_SRC elisp
  (defun autofeaturep (feature)
    "For a feature symbol 'foo, return a result equivalent to:
  (or (featurep 'foo-autoloads) (featurep 'foo))
  Does not support subfeatures."
    (catch 'result
      (let ((feature-name (symbol-name feature)))
        (unless (string-match "-autoloads$" feature-name)
          (let ((feature-autoloads (intern-soft (concat feature-name "-autoloads"))))
            (when (and feature-autoloads (featurep feature-autoloads))
              (throw 'result t))))
        (featurep feature))))
#+END_SRC

** Variables

   General settings about me that other packages can use. The biggest
   problem is guessing my email address based on what computer I am using:

#+BEGIN_SRC elisp
  (if (equal "howard.abrams" user-login-name)
      (setq user-mail-address "howard.abrams@workday.com")
    (setq user-mail-address "howard.abrams@gmail.com"))
#+END_SRC

*** Tabs vs Spaces

   I have learned to distrust tabs in my source code, so let's make
   sure that we only have spaces.

#+BEGIN_SRC elisp
  (setq-default indent-tabs-mode nil)
  (setq tab-width 2)
#+END_SRC

** Display Settings

   I've been using Emacs for many years, and appreciate a certain
   minimalist approach to its display. While you can turn these off
   with the menu items now, it is just as easy to set them here.

#+BEGIN_SRC elisp
  (setq initial-scratch-message "") ;; Uh, I know what Scratch is for
  (setq visible-bell t)             ;; Get rid of the beeps

  (unless (window-system)
    (menu-bar-mode 0))              ;; No menus... but only in text mode

  (when (window-system)
    (tool-bar-mode 0)               ;; Toolbars were only cool with XEmacs
    (scroll-bar-mode 0))            ;; Scrollbars are waste screen estate
#+END_SRC

** More Key Definitions

   Clearly, the most important keybindings are the function keys,
   right? Here is my list of needs:

   - *F1* - Help? Isn't Control-H good enough?
   - *F2* - Standard alternate meta key with lots of bindings
   - *F3* - Define a keyboard macro
   - *F4* - Replay a keyboard macro
   - *F5* - Repeat the last command ...
   - *F6* - Setup window or move forward with demonstration.
   - *F7* - Switch to another window
   - *F8* - Switch to buffer
   - *F9* - My other meta key for changing colors and other odd
     bindings that I actually don't use that often

#+BEGIN_SRC elisp
  (global-set-key (kbd "<f5>") 'repeat-complex-command)
  (global-set-key (kbd "<f6>") 'setup-windows)
  (global-set-key (kbd "<f7>") 'other-window)
  (global-set-key (kbd "<f8>") 'ido-switch-buffer)
#+END_SRC

   Change window configuration and then return to the old
   configuration with [[http://www.emacswiki.org/emacs/WinnerMode][winner-mode]].  Use =Control-C Arrow= keys to
   cycle through window/frame configurations.

#+BEGIN_SRC elisp
  (winner-mode 1)
#+END_SRC

** Better Newline

   Since =paredit= and other modes automatically insert final
   characters like semi-colons and parenthesis, what I really want is
   to hit return from the /end of the line/. Pretty simple function.

#+BEGIN_SRC elisp
  (defun newline-for-code ()
    "Inserts a newline character, but from the end of the current line."
    (interactive)
    (move-end-of-line 1)
    (newline-and-indent))
#+END_SRC

   And we can bind that to the free, /Meta-Return/:

#+BEGIN_SRC elisp
  (global-set-key (kbd "M-RET") 'newline-for-code)
#+END_SRC

** Key Chords

   Key Chords allows you to use any two keys pressed at the same time
   to trigger a function call. Interesting possibilities, but of
   course, you don't want it to make any mistakes.

   Like 'xo' seemed good for 'other-window' until I needed to type
   the word, 'ox'.

   I like vi's =.= command, where it quickly repeats the last command
   you did. Emacs has similar functionality, but I never remember
   =C-x z=, so let's map it to something else.

#+BEGIN_SRC elisp
  (when (autofeaturep 'key-chord)
        (require 'key-chord)
        (key-chord-mode +1)

        (key-chord-define-global ",." 'repeat)
        (key-chord-define-global "qw" 'query-replace)
        (key-chord-define-global "xb" 'ido-switch-buffer)
        (key-chord-define-global "xf" 'ido-find-file)

        (when (autofeaturep 'iy-go-to-char)
              (require 'iy-go-to-char)

              (key-chord-define-global "fg" 'iy-go-to-char)
              (key-chord-define-global "df" 'iy-go-to-char-backward)))
#+END_SRC

   The [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]] project allows a quick search for a particular
   character. In [[http://www.youtube.com/watch?v%3DNXTf8_Arl1w][Episode 6]] of [[http://www.emacsrocks.com][EmacsRocks]], [[http://twitter.com/emacsrocks][Magnar Sveen]] pulls it all
   together and makes a compelling case for micro-optimizations.
   We'll see if I can remember to use the feature.

** Recent File List

   According to [[http://www.emacswiki.org/emacs-es/RecentFiles][this article]], Emacs already has the recent file
   listing available, just not turned on.

#+BEGIN_SRC elisp
  (require 'recentf)
  (recentf-mode 1)
  (setq recentf-max-menu-items 25)
  (global-set-key (kbd "C-x C-r") 'recentf-open-files)
#+END_SRC

** Multiple Cursors

   While I'm not sure how often I will use [[https://github.com/emacsmirror/multiple-cursors][multiple-cursors]] project,
   I'm going to try to remember it is there. It doesn't have any
   default keybindings, so I set up the suggested:

#+BEGIN_SRC elisp
  (when (autofeaturep 'multiple-cursors)
        (require 'multiple-cursors)
        (global-set-key (kbd "C->") 'mc/mark-next-like-this)
        (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
        (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this))
#+END_SRC

** Auto Complete

   This feature scans the code and suggests completions for what you
   are typing. Useful at times ... annoying at others.

#+BEGIN_SRC elisp
  (when (autofeaturep 'auto-complete-config)
    (require 'auto-complete-config)
    (add-to-list 'ac-dictionary-directories (concat user-emacs-directory "ac-dict"))

    (set-default 'ac-sources
                 '(ac-source-abbrev
                   ac-source-dictionary
                   ac-source-yasnippet
                   ac-source-words-in-buffer
                   ac-source-words-in-same-mode-buffers
                   ac-source-semantic))

    (ac-config-default)
    (global-auto-complete-mode t))
#+END_SRC

   Note that we specify where a dictionary lives for each specific
   language, and if for some reason, a mode isn't getting the "AC"
   minor mode, you can add to it with this magic:

#+BEGIN_SRC elisp :tangle no
  (dolist (m '(python-mode js2-mode clojure-mode))
    (add-to-list 'ac-modes m))
#+END_SRC

** Abbreviation Mode

   Using the built-in [[http://www.emacswiki.org/emacs/AbbrevMode][Abbreviation Mode]], but setting it up only for
   the text modes:

#+BEGIN_SRC elisp
(add-hook 'text-mode-hook (lambda () (abbrev-mode 1)))
#+END_SRC

   While you can make abbreviations in situ, I figured I should
   /pre-load/ a bunch that I use:

#+BEGIN_SRC elisp
  (define-abbrev-table 'global-abbrev-table
    '(("HA" "Howard Abrams")
      ("CCB" "CI x CD x BP")
      ("WD" "Workday")
      ("btw" "by the way")
      ("func" "function")
      ("note" "*Note:*")
      ("OS" "OpenStack")
      ("NG" "AngularJS")
      ("JS" "JavaScript")
      ("CS" "CoffeeScript")))
#+END_SRC

   This allows me to write =os= as =OpenStack=, and if I want to write
   =os=, I just don't put a space or some punctuation behind it. The
   trick, however, is remembering what works.

   *Note:* Capitalizing the first letter, i.e. =Btw=, expands the
   abbreviation with an initial capital, i.e. =By the way= ... Sweet.

** Yasnippets

   The [[https://github.com/capitaomorte/yasnippet][yasnippet project]] allows me to create snippets of code that
   can be brought into a file, based on the language.

#+BEGIN_SRC elisp
  (when (autofeaturep 'yasnippet)
    (require 'yasnippet)
    (yas-global-mode 1))
#+END_SRC

   Inside the =snippets= directory should be directories for each
   mode, e.g.  =clojure-mode= and =org-mode=. This connects the mode
   with the snippets.

#+BEGIN_SRC elisp
    (add-to-list 'yas-snippet-dirs (concat user-emacs-directory "snippets"))
#+END_SRC

   [[https://code.google.com/p/js2-mode/][js2-mode]] is good, but its name means that Yas' won't automatically
   link it to its =js-mode=. This little bit of magic does the linking:

#+BEGIN_SRC elisp :tangle no
    (add-hook 'js2-mode-hook '(lambda ()
                                (make-local-variable 'yas-extra-modes)
                                (add-to-list 'yas-extra-modes 'js-mode)
                                (yas-minor-mode 1))))
#+END_SRC

** Note Grep

   First, we need to have the =find-grep= ignore =.git= directories
   and search for wholewords:

#+BEGIN_SRC elisp
  (setq grep-find-command
        "find . -type f '!' -wholename '*/.git/*' -print0 | xargs -0 -e grep -nHPi -e ")
  (setq rep-highlight-matches t)
#+END_SRC

   I use the standard [[http://emacswiki.org/emacs/GrepMode#toc1][grep package]] in Emacs and wrap it so that I
   can easily search through my notes. However, I'm using a later
   version of Gnu Grep. On Mac OS X, run these two commands:

#+BEGIN_EXAMPLE
brew tap homebrew/dupes
brew install homebrew/dupes/grep
#+END_EXAMPLE

   Now we can call the =ggrep= command:

#+BEGIN_SRC elisp
  (defun ngrep (reg-exp)
    "Searches the Notes and ORG directory tree for an expression.
  The pipe symbol separates an org-mode tag from the phrase to search,
  e.g. jquery|appendTo searches only the files with a 'jquery' tag."
    (interactive "sSearch note directories: ")
    (let ((search-dir "~/Notes ~/Technical")
          (options "--line-number --with-filename --word-regexp --ignore-case")
          (the-args (split-string reg-exp "\|")))
      (if (> (length the-args) 1)
          (let* ((the-tag (car the-args))
                 (reg-exp (combine-and-quote-strings (cdr the-args)))
                 (files   (split-string (shell-command-to-string
                               (concat
                                "grep -r --files-with-matches '#+TAGS: .*"
                                the-tag "' " search-dir)) "\n")))
            (progn
              (message "Searching for %s with tag of %s" reg-exp the-tag)
              (grep-find (concat "grep " options " " reg-exp " "
                                 (combine-and-quote-strings files)))))
        (let* ((file-exts '( "*.org" "*.md" "*.txt" "*.markdown"))
               (file-types (mapconcat (function (lambda (x) (concat "--include '" x "'")))  file-exts " ")))
          (progn
            (message "Searching in %s" search-dir)
            (grep-compute-defaults)
            (grep-find (concat "grep -r -e " reg-exp " " options " "
                               file-types " " search-dir)))))))

  (global-set-key (kbd "C-x C-n") 'ngrep)
  ;; (global-set-key (kbd "C-x C-r") 'rgrep)
#+END_SRC

   Don't forget that after doing a =C-x C-f= to find a file, you can
   hit another =M-f= to do a find the given directory (and subs).

   Also, you can do a full locate with =C-x C-l=:

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-x C-l") 'locate)
  (setq locate-command "mdfind")  ;; Use Mac OS X's Spotlight
#+END_SRC

** Spell Checking

   I like spell checking with [[http://www.emacswiki.org/emacs/FlySpell][FlySpell]], which uses =ispell=.

   To build a dictionary hash (seems important now), do this:

#+BEGIN_SRC sh :tangle no
  touch ~/.dictionary.txt
  buildhash ~/.dictionary.txt /usr/local/lib/english.aff ~/.dictionary.txt.hash
#+END_SRC

   Then, we can use it like:

#+BEGIN_SRC elisp
  (setq ispell-personal-dictionary
      (concat (getenv "HOME") "/.dictionary.txt"))

  (dolist (hook '(text-mode-hook org-mode-hook))
    (add-hook hook (lambda () (flyspell-mode 1))))
#+END_SRC

   If I find any =text-mode= derived mode that I don't want to
   spell-check, then I need to use the following:

#+BEGIN_SRC elisp :tangle no
  (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
    (add-hook hook (lambda () (flyspell-mode -1))))
#+END_SRC

** Online Thesaurus

   Using [[http://www.emacswiki.org/emacs/thesaurus.el][thesaurus.el]] to access the [[https://words.bighugelabs.com/][Big Huge Labs' Online Thesaurus]]
   while editing my expressive literary style in my text files.

#+BEGIN_SRC elisp
  (when (autofeaturep 'thesaurus)
    (require 'thesaurus)
    (thesaurus-set-bhl-api-key-from-file "~/.emacs.d/bighugelabs.apikey.txt")

    (define-key global-map (kbd "C-x t") 'thesaurus-choose-synonym-and-replace))
#+END_SRC

** Miscellaneous Settings
*** IDO (Interactively DO Things)

    According to [[http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/][Mickey]], IDO is the greatest thing.

#+BEGIN_SRC elisp
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode 1)
#+END_SRC

    According to [[https://gist.github.com/rkneufeld/5126926][Ryan Kneufeld]], we could make IDO work
    vertically, which is much easier to read.

#+BEGIN_SRC elisp
(setq ido-decorations                                                      ; Make ido-mode display vertically
      (quote
       ("\n-> "           ; Opening bracket around prospect list
        ""                ; Closing bracket around prospect list
        "\n   "           ; separator between prospects
        "\n   ..."        ; appears at end of truncated list of prospects
        "["               ; opening bracket around common match string
        "]"               ; closing bracket around common match string
        " [No match]"     ; displayed when there is no match
        " [Matched]"      ; displayed if there is a single match
        " [Not readable]" ; current diretory is not readable
        " [Too big]"      ; directory too big
        " [Confirm]")))   ; confirm creation of new file or buffer

(add-hook 'ido-setup-hook                                                  ; Navigate ido-mode vertically
          (lambda ()
            (define-key ido-completion-map [down] 'ido-next-match)
            (define-key ido-completion-map [up] 'ido-prev-match)
            (define-key ido-completion-map (kbd "C-n") 'ido-next-match)
            (define-key ido-completion-map (kbd "C-p") 'ido-prev-match)))
#+END_SRC

    I guess you can call =ido-use-url-at-point= with Markdown to jump
    to the URLs. Perhaps?

*** SMEX

    Built using [[*IDO%20(Interactively%20DO%20Things)][IDO]].

#+BEGIN_SRC elisp
  (require 'smex)
  (smex-initialize) ; Can be omitted. This might cause a (minimal) delay

  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-z") 'smex)  ;; Zap to char isn't so helpful
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)

  ;; This is our old M-x.
  (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
#+END_SRC

   Not crazy about =zap-to-char= being so close to the very useful
   =M-x= sequence, so...

#+BEGIN_SRC elisp
  (global-set-key (kbd "M-z") 'smex-major-mode-commands)
#+END_SRC

*** Backup Settings

    This setting moves all backup files to a central location.
    Got it from [[http://whattheemacsd.com/init.el-02.html][this page]].

#+BEGIN_SRC elisp
  (setq backup-directory-alist
        `(("." . ,(expand-file-name
                   (concat user-emacs-directory "backups")))))
#+END_SRC

   Make backups of files, even when they're in version control

#+BEGIN_SRC elisp
  (setq vc-make-backup-files t)
#+END_SRC

*** Line Numbers

    Turn =nlinum-mode= on/off with =Command-K= (see the [[*Macintosh][Macintosh]]
    section above).  However, turn this on automatically for
    programming modes?

#+BEGIN_SRC elisp
  (add-hook 'prog-mode-hook 'nlinum-mode)
#+END_SRC

*** Smart Scan

    Use the =M-n= to search the buffer for the word the cursor is
    currently pointing. =M-p= to go backwards.

#+BEGIN_SRC elisp
  (load-library "smart-scan")
#+END_SRC

*** Dired Options

    The associated group name isn't too useful when viewing the dired
    output.

#+BEGIN_SRC elisp :tangle no
  (setq dired-listing-switches "-AlohGD -dired")
  (setq ls-lisp-use-insert-directory-program t)
  (setq insert-directory-program "/usr/local/bin/gls")
#+END_SRC

    This enhancement to dired hides the ugly details until you hit
    '(' and shows the details with ')'. I also change the [...] to a
    simple asterisk.

#+BEGIN_SRC elisp
  (when (autofeaturep 'dired-details)
    (require 'dired-details)
    (dired-details-install)
    (setq dired-details-hidden-string "* "))
#+END_SRC

*** Save Place

    The [[http://www.emacswiki.org/emacs/SavePlace][Save Place]] mode will... well, save your place in between
    Emacs sessions.

#+BEGIN_SRC elisp
  (require 'saveplace)
  (setq-default save-place t)
#+END_SRC

*** Strip Whitespace on Save

    When I save, I want to always, and I do mean always strip all
    trailing whitespace from the file.

#+BEGIN_SRC elisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

*** Uniquify

    Get rid of silly <1> and <2> to buffers with the same file name,
    using [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html][uniquify]].

#+BEGIN_SRC elisp
  (require 'uniquify)
#+END_SRC

*** Expand Region

    Wherever you are in a file, and whatever the type of file, you
    can slowly increase a region selection by logical segments.

#+BEGIN_SRC elisp
  (when (autofeaturep 'expand-region)
        (require 'expand-region)
        (global-set-key (kbd "C-=") 'er/expand-region))
#+END_SRC

*** Better Searching and Visual Regular Expressions

    Only after you've started an =isearch-forward= do you wish you had
    regular expressions available, so why not just switch those defaults?

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-set-key (kbd "C-M-s") 'isearch-forward)
  (global-set-key (kbd "C-M-r") 'isearch-backward)
#+END_SRC

    The [[https://github.com/benma/visual-regexp.el][Visual Regular Expressions]] project highlights the matches
    while you try to remember the differences between Perl's regular
    expressions and Emacs'...

    Begin with =C-c r= then type the regexp. To see the highlighted
    matches, type =C-c a= before you hit 'Return' to accept it.

#+BEGIN_SRC elisp
  (when (autofeaturep 'visual-regexp)
    (require 'visual-regexp)
    (define-key global-map (kbd "C-c r") 'vr/replace)
    (define-key global-map (kbd "C-c q") 'vr/query-replace)

    ;; if you use multiple-cursors, this is for you:
    (define-key global-map (kbd "C-c m") 'vr/mc-mark))
#+END_SRC

*** Flycheck

    [[https://github.com/flycheck/flycheck][Flycheck]] seems to be quite superior to good ol' Flymake.

#+BEGIN_SRC elisp
  (when (autofeaturep 'flycheck)
    (require 'flycheck)

    (add-hook 'after-init-hook #'global-flycheck-mode))
#+END_SRC

    The most interesting aspect is that it doesn't support Clojure.

* Org-Mode

  See [[file:emacs-org.org][emacs-org-mode.el]] for details on my [[http://www.orgmode][Org-Mode]] settings.

#+BEGIN_SRC elisp
  (require 'init-org-mode)
#+END_SRC

* Programming Languages
** Fixme in Comments

   Wanting to play around with the concept of highlighting certain
   comments with the TODO or FIXME keywords:

#+BEGIN_SRC elisp
  (when (autofeaturep 'fic-mode)
    (require 'fic-mode)
    (add-hook 'js2-mode-hook 'turn-on-fic-mode)
    (add-hook 'coffee-mode-hook 'turn-on-fic-mode)
    (add-hook 'python-mode-hook 'turn-on-fic-mode)
    (add-hook 'clojure-mode-hook 'turn-on-fic-mode)
    (add-hook 'emacs-lisp-mode-hook 'turn-on-fic-mode))
#+END_SRC

** Clojure

   See [[file:emacs-clojure.org][emacs-clojure.el]] for details on working with [[http://clojure.org][Clojure]].
   Not sure if I should just load it directly, like:

#+BEGIN_SRC elisp :tangle no
  (require 'init-clojure)
#+END_SRC

   Or if I should load it after the Clojure mode kicks in?

#+BEGIN_SRC elisp
  (eval-after-load 'clojure-mode '(require 'init-clojure))
#+END_SRC

** Java

   Eh ... why use Java anymore?

** Python

   See [[file:emacs-python.org][emacs-python.el]] for details on working with Python.
   Not sure if I should just load it directly, like:

#+BEGIN_SRC elisp :tangle no
  (load-library "init-python")
#+END_SRC

** JavaScript

   See [[file:emacs-javascript.org][emacs-javascript.el]] for details on working with JavaScript.

#+BEGIN_SRC elisp :tangle no
;;  (load-library "init-javascript")
#+END_SRC

** HTML, CSS and other Web Programming

   See [[file:emacs-web.org][emacs-web.el]] for details on working with HTML and its ilk.

#+BEGIN_SRC elisp :tangle no
  (load-library "init-web")
#+END_SRC

** Emacs Lisp

   The most important change to Emacs Lisp is colorizing the
   variables:

#+BEGIN_SRC elisp
  (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode)
  (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
#+END_SRC

   Might as well pretty up the lambdas, because, we can!

#+BEGIN_SRC elisp
  (font-lock-add-keywords 'emacs-lisp-mode
                          '(("(\\(lambda\\)\\>" (0 (prog1 ()
                                                     (compose-region (match-beginning 1)
                                                                     (match-end 1)
                                                                     ?λ))))))
#+END_SRC

* Tools
** Git

   Git is [[http://emacswiki.org/emacs/Git][already part of Emacs]]. However, [[http://philjackson.github.com/magit/magit.html][Magit]] is sweet.

#+BEGIN_SRC elisp
  (autoload 'magint "magit"
    "Hooking Git up to supported files." t nil)

  (global-set-key (kbd "M-C-g") 'magit-status)
#+END_SRC

   I install and use the [[https://github.com/syohex/emacs-git-gutter-fringe][Git Gutter Fringe]] as it works better with
   windowing versions of Emacs.

#+BEGIN_SRC elisp
  (if (autofeaturep 'git-gutter-fringe)
      (when (window-system)
          (require 'git-gutter-fringe)
          (global-git-gutter-mode +1)
          (setq-default indicate-buffer-boundaries 'left)
          (setq-default indicate-empty-lines +1)))
#+END_SRC

** Markdown

   Don't use Markdown nearly as much as I used to, but I'm surprised
   that the following extension-associations aren't the default:

#+BEGIN_SRC elisp
  (autoload 'markdown-mode "markdown-mode.el"
     "Major mode for editing Markdown files" t)
  (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
#+END_SRC

   Using the =org-text-wrapper= function, I create some wrapper
   functions to make it easier to bold text in Markdown files:

#+BEGIN_SRC elisp
  (defun markdown-bold () "Wraps the region with double asterisks."
    (interactive)
    (org-text-wrapper "**"))
  (defun markdown-italics () "Wraps the region with asterisks."
    (interactive)
    (org-text-wrapper "*"))
  (defun markdown-code () "Wraps the region with equal signs."
    (interactive)
    (org-text-wrapper "`"))
#+END_SRC

   Now I can associate some keystrokes to =markdown-mode=:

#+BEGIN_SRC elisp
  (add-hook 'markdown-mode-hook
        (lambda ()
          (local-set-key (kbd "A-b") 'markdown-bold)
          (local-set-key (kbd "A-i") 'markdown-italics)
          (local-set-key (kbd "A-=") 'markdown-code)))
#+END_SRC

** Wiki

   Now that Atlassian changed this Wiki system so that [[https://code.google.com/p/confluence-el/][confluence.el]]
   doesn't work anymore (yeah, not an improvement, Atlassian), I can
   still use the =confluence-edit-mode= for anything with a =.wiki=
   extension.

#+BEGIN_SRC elisp
  (autoload 'confluence-edit-mode "confluence-edit-mode.el"
     "Major mode for editing Wiki documents" t)
  (add-to-list 'auto-mode-alist '("\\.wiki\\'" . confluence-edit-mode))
#+END_SRC

   I would also like to create and use some formatting wrappers.

#+BEGIN_SRC elisp
  (defun wiki-bold () "Wraps the region with single asterisks."
    (interactive)
    (org-text-wrapper "*"))
  (defun wiki-italics () "Wraps the region with underbars."
    (interactive)
    (org-text-wrapper "_"))
  (defun wiki-code () "Wraps the region with curly brackets."
    (interactive)
    (org-text-wrapper "{{" "}}"))
#+END_SRC

   Now I can associate some keystrokes to =markdown-mode=:

#+BEGIN_SRC elisp
  (add-hook 'confluence-edit-mode-hook
        (lambda ()
          (local-set-key (kbd "A-b") 'wiki-bold)
          (local-set-key (kbd "A-i") 'wiki-italics)
          (local-set-key (kbd "A-=") 'wiki-code)))
#+END_SRC

** PlantUML and Graphviz

   Install the Graphviz project using Homebrew:

#+BEGIN_SRC sh :tangle no
  brew install graphviz
  brew link graphviz
  brew install plantuml
#+END_SRC

   To get [[http://plantuml.sourceforge.net/download.html][PlantUML]] working in Emacs, first, download the Jar and place
   in the =~/bin= directory. We then set the "mode" working for
   editing the files:

#+BEGIN_SRC elisp
  (setq plantuml-jar-path (concat (getenv "HOME") "/bin/plantuml.jar"))
#+END_SRC

   Second, to get [[http://zhangweize.wordpress.com/2010/08/25/creating-uml-images-by-using-plantuml-and-org-babel-in-emacs/][PlantUML]] working in org-mode, set a different variable:

#+BEGIN_SRC elisp
  (setq org-plantuml-jar-path (concat (getenv "HOME") "/bin/plantuml.jar"))
#+END_SRC

* Applications
** EShell

  See [[file:emacs-eshell.org][emacs-eshell.el]] for details of configuring and using EShell.

#+BEGIN_SRC elisp
  (require 'init-eshell)
#+END_SRC

** Circe

   I find reading Twitter and IRC in Emacs a good idea. Really. Small
   bits of the Emacs window are accessible and whatnot.

#+BEGIN_SRC elisp
  (when (autofeaturep 'circe)
    (require 'init-irc))
#+END_SRC

** Chatting

   Using the [[http://www.emacswiki.org/emacs/JabberEl][jabber.el]] project to connect up to Google Talk and what
   not. To begin, make sure you =brew install gnutls=

#+BEGIN_SRC elisp
  (when (autofeaturep 'jabber)
    (require 'jabber)
    (setq starttls-use-gnutls t
          starttls-gnutls-program "gnutls-cli"
          starttls-extra-arguments '("--starttls" "--insecure"))
    (setq
     jabber-history-enabled t
     jabber-use-global-history nil
     jabber-backlog-number 40
     jabber-backlog-days 30)

    (defun my-jabber-chat-delete-or-bury ()
      (interactive)
      (if (eq 'jabber-chat-mode major-mode)
          (condition-case e
              (delete-frame)
            (error
             (if (string= "Attempt to delete the sole visible or iconified frame"
                          (cadr e))
                 (bury-buffer))))))

    (define-key jabber-chat-mode-map [escape]
      'my-jabber-chat-delete-or-bury)

    (when (autofeaturep 'autosmiley)
      (add-hook 'jabber-chat-mode-hook 'autosmiley-mode)))
#+END_SRC

  To chat simply press: =C-x C-j C-c= ... hahaha. I doubt I can
  remember that one. Perhaps.

* Technical Artifacts

  Before you can build this on a new system, make sure that you put
  the cursor over any of these properties, and hit: =C-c C-c=

#+DESCRIPTION: A literate programming version of my Emacs Initialization script, loaded by the .emacs file.
#+PROPERTY:    results silent
#+PROPERTY:    tangle ~/.emacs.d/elisp/init-main.el
#+PROPERTY:    eval no-export
#+PROPERTY:    comments org
#+OPTIONS:     num:nil toc:nil todo:nil tasks:nil tags:nil
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
