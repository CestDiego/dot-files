#+TITLE:  Emacs Demo Mode
#+AUTHOR: Howard Abrams
#+EMAIL:  howard.abrams@gmail.com
#+DATE:   [2014-01-25 Sat]
#+TAGS:   emacs

* Introduction

  When making demonstrations of new products, technologies and other
  geekery, I love the versatility of starting up Emacs and "going to
  town". However, I don't want to fat-finger, mentally burp, or even
  delay the gratification while I type, so welcome to my "demo" mode.

  Using the library is a three step process:

  1. Load the library in your own Elisp source code file
  2. Create a collection of functions that "do things".
  3. Call the =demo-start= function with the ordered list of
     functions.

  For instance:

#+BEGIN_EXAMPLE
  (load-library "demo")   ;; Load this library of functions

  ;; Define the first of many steps that do things.
  (defun my-demo/step-1 ()
    (delete-other-windows)
    (find-file "~/technical/emacs-demo/emacs-demo-start.org")
    (org-tree-slide-mode)
    (text-scale-set 2))

  (defun my-demo/step-2 ()
    (demo/org-presentation-return))
  
  ;; Wrap the collection of functions in another function...
  (defun my-demo ()
     "My fabulous demonstration."
     (interactive)
     (demo-start (list
                     'my-demo/step-1
                     'my-demo/step-2
                     ;; ...
                   )))

  (my-demo) ;; Optionally start the demo when file is loaded.
#+END_EXAMPLE

  Each "step" is a series of Elisp functions that "do things".
  For instance:

  - =find-file=
  - =text-scale-set=
  - =split-window-horizontally= (or vertically)
  - =eshell= ... followed by =(insert "some command")= and
    =(eshell-send-input)=

  Pretty simple, actually.

* State

  To begin, we need a "global" variable (shudder) that keeps track of
  the current state of the demonstration.

#+BEGIN_SRC elisp
  (defvar demo/step 0  "Stores the current demo 'step' function.")
#+END_SRC

#+BEGIN_SRC elisp
  (defvar demo/steps '() "The list of functions to be executed in order.")
#+END_SRC

* Starting a Demonstration

  When we start a demonstration, we would pass in a list of functions
  to call for each step, and then call =demo-step= to execute the
  first one on the list.

#+BEGIN_SRC elisp
  (defun demo-start (steps)
     "Start (or restart) the current demonstration and kick off the first step."
     (setq demo/step 0)          ;; Reset the step to the beginning
     (setq demo/steps steps)     ;; Store the steps.
     (demo-step))
#+END_SRC

* Next Step

  Hitting the <F6> key should be bound to triggering the next step in
  the demonstration.

#+BEGIN_SRC elisp
  (defun demo-step (&optional step)
    "Execute the next step in the current demonstration."
    (interactive "P")
      (if step
          (setq demo/step step)    ;; Changing Global state, yay!
        (setq demo/step (1+ demo/step)))
      (let
          ;; At this point, step is 1-based, and I need it 0-based
          ;; and f-step is the function to call for this step...
          ((f-step (nth (1- demo/step) demo/steps)))
        (if f-step
              (funcall f-step)
          (message "Finished the entire demonstration."))))
#+END_SRC

  Bind the =demo-step= function to the F6 key:

#+BEGIN_SRC elisp
  (global-set-key (kbd "<f6>") 'demo-step)
#+END_SRC

* Supporting Functions

  The following functions seem to be useful for doing these sorts of
  demonstrations.

** Hiding the Modeline

   Call the =hidden-mode-line= when displaying images, or just not
   wanting to be bothered by the sight of the mode.

#+BEGIN_SRC elisp
  ;; See http://bzg.fr/emacs-hide-mode-line.html
  (defvar-local hidden-mode-line-mode nil)
  (defvar-local hide-mode-line nil)
  
  (define-minor-mode hidden-mode-line-mode
    "Minor mode to hide the mode-line in the current buffer."
    :init-value nil
    :global nil
    :variable hidden-mode-line-mode
    :group 'editing-basics
    (if hidden-mode-line-mode
        (setq hide-mode-line mode-line-format
              mode-line-format nil)
      (setq mode-line-format hide-mode-line
            hide-mode-line nil))
    (force-mode-line-update)
    (set-window-buffer nil (current-buffer))
    (when (and (called-interactively-p 'interactive)
               hidden-mode-line-mode)
      (run-with-idle-timer
       0 nil 'message
       (concat "Hidden Mode Line Mode enabled.  "
               "Use M-x hidden-mode-line-mode RET to make the mode-line appear."))))
#+END_SRC

** Making a Side Window

   Typically, we make a side window that is large enough to have some
   fun in, as the main window would serve as little more than an
   outline.

#+BEGIN_SRC elisp
  (defun demo/make-side-window ()
    (split-window-horizontally)
    (shrink-window-horizontally 10)
    (other-window 1))
#+END_SRC

** Load a File in the Side Window

   Splits the window and loads a file.

#+BEGIN_SRC elisp
  (defun demo/load-side-window (file)
    (demo/make-side-window)
    (find-file file))
#+END_SRC

** Starting an ORG Presentation

   Since I often have an org-mode file on the side of the screen to
   demonstrate an outline of what I will be demoing, I made it a
   function.

#+BEGIN_SRC elisp
  (require 'org-tree-slide)

  (defvar demo/org-presentation-file "")  
  (defvar demo/org-presentation-buffer "")  

  (defun demo/org-presentation (org-file)
    (delete-other-windows)
    (find-file org-file)
    (setq demo/org-presentation-file org-file)  
    (setq demo/org-presentation-buffer (buffer-name))
    (org-tree-slide-mode)
    (text-scale-set 2))
#+END_SRC

** Jumping Back to the Presentation

   In this case, we've been doing some steps, and the screen is
   "messed up", calling this function returns back to the
   presentation.

#+BEGIN_SRC elisp
  (defun demo/org-presentation-return ()
    (switch-to-buffer demo/org-presentation-buffer)
    (delete-other-windows)
    (org-tree-slide-move-next-tree))
#+END_SRC

** Advance Presentation without Changing Focus

   We can advance the presentation, but return to the window where
   our focus was initially.

#+BEGIN_SRC elisp
  (defun demo/org-presentation-advance ()
    (let ((orig-window (current-buffer)))
      (switch-to-buffer demo/org-presentation-buffer)
      (org-tree-slide-move-next-tree)
      (switch-to-buffer orig-window)))
#+END_SRC

* Technical Section
  
  This file originally came from an [[http://orgmode.org][org-mode]] file.
  Create the script by tangling it with: =C-c C-v t=
  
#+PROPERTY: tangle ~/.emacs.d/elisp/demo.el
#+PROPERTY: comments org
#+PROPERTY: shebang #!/usr/bin/env emacs
#+DESCRIPTION: A way to execute a series of "steps" to demonstration some emacs feature
