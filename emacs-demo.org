#+TITLE:  Emacs Demo Mode
#+AUTHOR: Howard Abrams
#+EMAIL:  howard.abrams@gmail.com
#+DATE:   [2014-01-25 Sat]
#+TAGS:   emacs

* Introduction

  When making demonstrations of new products, technologies and other
  geekery, I love the versatility of starting up Emacs and "going to
  town". However, I don't want to fat-finger, mentally burp, or even
  delay the gratification while I type, so welcome to my "demo" mode.

  Using the library is a three step process:

  1. Load the library in your own Elisp source code file
  2. Create a collection of functions that "do things".
  3. Call the =demo-start= function with the ordered list of
     functions.

  For instance:

#+BEGIN_EXAMPLE
  (load-library "demo")   ;; Load this library of functions

  ;; Define the first of many steps that do things.
  (defun my-demo/step-1 ()
    (delete-other-windows)
    (find-file "~/technical/emacs-demo/emacs-demo-start.org")
    (org-tree-slide-mode)
    (text-scale-set 2))

  (defun my-demo/step-2 ()
    (demo/org-presentation-return))

  ;; Wrap the collection of functions in another function...
  (defun my-demo ()
     "My fabulous demonstration."
     (interactive)
     (demo-start (list
                     'my-demo/step-1
                     'my-demo/step-2
                     ;; ...
                   )))

  (my-demo) ;; Optionally start the demo when file is loaded.
#+END_EXAMPLE

  Each "step" is a series of Elisp functions that "do things".
  For instance:

  - =find-file=
  - =text-scale-set=
  - =split-window-horizontally= (or vertically)
  - =eshell= ... followed by =(insert "some command")= and
    =(eshell-send-input)=

  Pretty simple, actually.

* State

  To begin, we need a "global" variable (shudder) that keeps track of
  the current state of the demonstration.

#+BEGIN_SRC elisp
  (defvar demo/step 0  "Stores the current demo 'step' function.")
#+END_SRC

#+BEGIN_SRC elisp
  (defvar demo/steps '() "The list of functions to be executed in order.")
#+END_SRC

* Starting a Demonstration

  When we start a demonstration, we would pass in a list of functions
  to call for each step, and then call =demo-step= to execute the
  first one on the list.

#+BEGIN_SRC elisp
  (defun demo-start (steps)
     "Start (or restart) the current demonstration and kick off the first step."
     (setq demo/step 0)          ;; Reset the step to the beginning
     (setq demo/steps steps)     ;; Store the steps.
     (demo-step))
#+END_SRC

* Next Step

  Hitting the <F6> key should be bound to triggering the next step in
  the demonstration.

#+BEGIN_SRC elisp
  (defun demo-step (&optional step)
    "Execute the next step in the current demonstration."
    (interactive "P")
      (if step
          (setq demo/step step)    ;; Changing Global state, yay!
        (setq demo/step (1+ demo/step)))
      (let
          ;; At this point, step is 1-based, and I need it 0-based
          ;; and f-step is the function to call for this step...
          ((f-step (nth (1- demo/step) demo/steps)))
        (if f-step
            (progn
              (funcall f-step)
              (message "  %d" demo/step))
          (message "Finished the entire demonstration."))))
#+END_SRC

  Bind the =demo-step= function to the F6 key:

#+BEGIN_SRC elisp
  (global-set-key (kbd "<f6>") 'demo-step)
#+END_SRC

  Position or advance the slide? Depends...

  #+BEGIN_SRC elisp
    (defun demo/set-mouse-or-advance (evt)
      "If clicked on the right side of any window, the demonstration
      advances a step. Otherwise, it just position the point in the
      window like normal."
      (interactive "e")
      (if (posn-area (event-start evt))  ;; Clicked in special area?
          (demo-step)
        (let ((col (car (posn-col-row (event-start evt))))
              (wid (window-width (posn-window (event-start evt)))))
          (if (> col (- wid 4))
              (demo-step)
            (mouse-set-point evt)))))

    (defun ignore-event (evt)
      (interactive "P")
      (message ""))
    (global-set-key (kbd "<mouse-1>") 'demo/set-mouse-or-advance)
    (global-set-key [nil mouse-1] 'demo-step)
    (global-set-key [nil wheel-up] 'ignore-event)
    (global-set-key [nil wheel-down] 'ignore-event)
    (global-set-key [nil wheel-left] 'ignore-event)
    (global-set-key [nil wheel-right] 'ignore-event)
  #+END_SRC

* Supporting Functions

  The following functions seem to be useful for doing these sorts of
  demonstrations.

** Auto Loading of Available Features

   The following "supporting functions" often depend on other packages
   from ELPA, but we don't want to simply 'require' something that
   hasn't been installed. This function can be used to look up
   packages that can be loaded without barfing.

#+BEGIN_SRC elisp
  (defun autofeaturep (feature)
    "For a feature symbol 'foo, return a result equivalent to:
  (or (featurep 'foo-autoloads) (featurep 'foo))
  Does not support subfeatures."
    (catch 'result
      (let ((feature-name (symbol-name feature)))
        (unless (string-match "-autoloads$" feature-name)
          (let ((feature-autoloads (intern-soft (concat feature-name "-autoloads"))))
            (when (and feature-autoloads (featurep feature-autoloads))
              (throw 'result t))))
        (featurep feature))))
#+END_SRC

** Fancy Region Highlighting

   When talking about a single function or area, we use the
   =expand-region= project along with the =fancy-narrow=:

#+BEGIN_SRC elisp
  (when (autofeaturep 'expand-region)
    (require 'expand-region)
    (global-set-key (kbd "C-=") 'er/expand-region))

  (when (autofeaturep 'fancy-narrow)
    (require 'fancy-narrow)
    (global-set-key (kbd "M-C-=") 'highlight-section)
    (global-set-key (kbd "M-C-+") 'fancy-widen))
#+END_SRC

   While sometimes I want highlight some code, it is usually a
   function, so instead of remembering two key combinations, let's
   just have the =C-+= narrow to the region if active, otherwise,
   narrow to the function:

#+BEGIN_SRC elisp
  (defun highlight-section ()
    "If the region is active, call 'fancy-narrow-to-region on it,
  otherwise, call 'fancy-narrow-to-defun, and see what happens."
    (interactive)
    (if (region-active-p)
        (fancy-narrow-to-region (region-beginning) (region-end))
      (fancy-narrow-to-defun)))
#+END_SRC

** Hiding the Modeline

   Call the =hidden-mode-line= when displaying images, or just not
   wanting to be bothered by the sight of the mode.

#+BEGIN_SRC elisp
  ;; See http://bzg.fr/emacs-hide-mode-line.html
  (defvar-local hidden-mode-line-mode nil)
  (defvar-local hide-mode-line nil)

  (define-minor-mode hidden-mode-line-mode
    "Minor mode to hide the mode-line in the current buffer."
    :init-value nil
    :global nil
    :variable hidden-mode-line-mode
    :group 'editing-basics
    (if hidden-mode-line-mode
        (setq hide-mode-line mode-line-format
              mode-line-format nil)
      (setq mode-line-format hide-mode-line
            hide-mode-line nil))
    (force-mode-line-update)
    (set-window-buffer nil (current-buffer))
    (when (and (called-interactively-p 'interactive)
               hidden-mode-line-mode)
      (run-with-idle-timer
       0 nil 'message
       (concat "Hidden Mode Line Mode enabled.  "
               "Use M-x hidden-mode-line-mode RET to make the mode-line appear."))))
#+END_SRC

** Making a Side Window

   Typically, we make a side window that is large enough to have some
   fun in, as the main window would serve as little more than an
   outline.

#+BEGIN_SRC elisp
  (defun demo/make-side-window ()
    (split-window-horizontally)
    ; (shrink-window-horizontally 10)
    (other-window 1))
#+END_SRC

** Load a File in the Side Window

   Splits the window and loads a file.

#+BEGIN_SRC elisp
  (defun demo/load-side-window (file)
    (demo/make-side-window)
    (find-file file))
#+END_SRC

   Would be nice to load up a file and automatically highlight some
   lines.

#+BEGIN_SRC elisp
  (defun demo/load-fancy-side-window (file type line1 line2 &optional side)
    "Load up a file in a side window, and then use the family region highlighting to show off some of the file."
    (if side (demo/make-side-window))
    (find-file file)
    (let ((start line1)
          (end line2))
      (unless (eq type 'char)
        (goto-line line1)
        (setq start (point))
        (goto-line (1+ line2))
        (setq end (point)))
      (fancy-narrow-to-region start end)))

  ;; (demo/load-fancy-side-window "~/Work/wpc-ci/verify" 'line 21 25)
#+END_SRC
** Starting an ORG Presentation

   Since I often have an org-mode file on the side of the screen to
   demonstrate an outline of what I will be demoing, I made it a
   function.

#+BEGIN_SRC elisp
  (require 'org-tree-slide)

  (defvar demo/org-presentation-file "")
  (defvar demo/org-presentation-buffer "")

  (defun demo/org-presentation (org-file)
    (delete-other-windows)
    (find-file org-file)
    (setq demo/org-presentation-file org-file)
    (setq demo/org-presentation-buffer (buffer-name))
    (setq org-tree-slide-heading-emphasis t)
    (flyspell-mode -1)
    (org-tree-slide-mode)
    (text-scale-set 2))
#+END_SRC

** Jumping Back to the Presentation

   In this case, we've been doing some steps, and the screen is
   "messed up", calling this function returns back to the
   presentation.

#+BEGIN_SRC elisp
  (defun demo/org-presentation-return-noadvance ()
    (switch-to-buffer demo/org-presentation-buffer)
    (delete-other-windows))
#+END_SRC

#+BEGIN_SRC elisp
  (defun demo/org-presentation-return ()
    (demo/org-presentation-return-noadvance)
    (org-tree-slide-move-next-tree))
#+END_SRC

** Advance Presentation without Changing Focus

   We can advance the presentation, but return to the window where
   our focus was initially.

#+BEGIN_SRC elisp
  (defun demo/org-presentation-advance ()
    (let ((orig-window (current-buffer)))
      (switch-to-buffer demo/org-presentation-buffer)
      (org-tree-slide-move-next-tree)
      (switch-to-buffer orig-window)))
#+END_SRC

** Display an Image on the Side

#+BEGIN_SRC elisp
  (defun demo/show-an-image (image-file)
    (split-window-horizontally)
    (other-window 1)
    (find-file image-file)
    (hidden-mode-line-mode))
#+END_SRC

** Display an HTML Page

   The easiest way to open a URL for the default browser is simply to
   call, =(browser-url-of-buffer)= (assuming, of course, that it is an
   HTML file). However, if we want the HTML to be shown in an
   impatient mode...

#+BEGIN_SRC elisp
  (defun demo/show-impatient-html ()
     "Shows the current HTML buffer in a browser where all changes are immediately displayed.
      Requires both impatient-mode and simple-httpd packages."
     (interactive)
     (let ((name (buffer-name (current-buffer))))
       (require 'impatient-mode)
       (require 'simple-httpd)
       (impatient-mode t)
       (setq httpd-port 8888)
       (httpd-start)
       (browse-url (concat "http://localhost:8888/imp/live/" name))))
#+END_SRC

** Switch Framesize

   During a demonstration, it might be nice to toggle between
   full screen and "regular window" in a programmatic way:

#+BEGIN_SRC elisp
  (defun toggle-fullscreen ()
    "Toggle full screen"
    (interactive)
    (set-frame-parameter
       nil 'fullscreen
       (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))
#+END_SRC

   We can force the window to be full screen:

#+BEGIN_SRC elisp
  (defun frame-fullscreen ()
    "Set the frame window to cover the full screen."
    (interactive)
    (set-frame-parameter nil 'fullscreen 'fullboth))
#+END_SRC

   Let's make a right-side frame window:

#+BEGIN_SRC elisp
  (defun frame-leftside ()
    "Set the window frame to be exactly half of the screen on the left."
    (interactive)
    (let* ((full-pixels (- (x-display-pixel-width) 16))
           (full-width  (/ full-pixels (frame-char-width)))
           (dest-width (/ full-width 2)))
      (set-frame-parameter nil 'fullscreen nil)
      (set-frame-parameter nil 'width dest-width)
      (set-frame-parameter nil 'left 0)))
#+END_SRC

   To get the values for a particular frame, do:

#+BEGIN_SRC elisp :results list
(frame-parameters nil)
#+END_SRC

#+RESULTS:
- (tool-bar-position . top)
- (parent-id)
- (explicit-name)
- (display . "Mac")
- (visibility . t)
- (icon-name)
- (window-id . "4301978032")
- (top . 0)
- (left . 0)
- (buried-buffer-list)
- (buffer-list #<buffer emacs-demo.org> #<buffer *Help*> #<buffer .emacs> #<buffer  *Minibuf-1*> #<buffer *eshell*> #<buffer #1101> #<buffer personal.org> #<buffer :home> #<buffer irc.ciphermonkeys.org:6667> #<buffer emacs.org> #<buffer .emacs-ext.el> #<buffer *GNU Emacs*> #<buffer *scratch*>)
- (unsplittable)
- (minibuffer . #<window 4 on  *Minibuf-0*>)
- (modeline . t)
- (width . 178)
- (height . 50)
- (name . "Emacs@HABRAMS-01.local")
- (environment)
- (cursor-color . "#de935f")
- (background-mode . dark)
- (display-type . color)
- (horizontal-scroll-bars . t)
- (window-system . mac)
- (alpha)
- (scroll-bar-width . 0)
- (cursor-type . box)
- (auto-lower)
- (auto-raise)
- (icon-type)
- (menu-bar-lines . 1)
- (fullscreen . fullscreen)
- (title)
- (buffer-predicate)
- (tool-bar-lines . 0)
- (right-fringe . 8)
- (left-fringe . 8)
- (line-spacing)
- (screen-gamma)
- (border-color . "#282a2e")
- (mouse-color . "black")
- (background-color . "#1d1f21")
- (foreground-color . "#c5c8c6")
- (vertical-scroll-bars)
- (internal-border-width . 0)
- (border-width . 0)
- (font . "-*-Source Code Pro-normal-normal-normal-*-14-*-*-*-m-0-iso10646-1")
- (font-backend mac-ct)

* Technical Section

  This file originally came from an [[http://orgmode.org][org-mode]] file.
  Create the script by tangling it with: =C-c C-v t=

#+PROPERTY: tangle ~/.emacs.d/elisp/demo.el
#+PROPERTY: comments org
#+PROPERTY: results silent
#+PROPERTY: shebang #!/usr/bin/env emacs
#+DESCRIPTION: A way to execute a series of "steps" to demonstration some emacs feature
